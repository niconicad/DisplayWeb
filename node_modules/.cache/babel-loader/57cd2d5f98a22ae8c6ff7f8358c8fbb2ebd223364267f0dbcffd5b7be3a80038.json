{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n\n  国际化，网页自动翻译。\n  作者：管雷鸣\n  开原仓库：https://github.com/xnx3/translate\n\n */\nconst translate = {\n  /*\n   * 当前的版本\n   */\n  version: '2.6.0.20230816',\n  useVersion: 'v1',\n  //当前使用的版本，默认使用v1. 可使用 setUseVersion2(); //来设置使用v2\n  setUseVersion2: function () {\n    translate.useVersion = 'v2';\n  },\n  /*\n   * 翻译的对象，也就是 new google.translate.TranslateElement(...)\n   */\n  translate: null,\n  /*\n   * 支持哪些语言切换，包括：de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr\n   * 已废弃，请使用 translate.selectLanguageTag.languages \n   */\n  includedLanguages: 'zh-CN,zh-TW,en',\n  /*\n   * 资源文件url的路径\n     */\n  resourcesUrl: '//res.zvo.cn/translate',\n  /**\n   * 默认出现的选择语言的 select 选择框，可以通过这个选择切换语言。\n   */\n  selectLanguageTag: {\n    /* 是否显示 select选择语言的选择框，true显示； false不显示。默认为true */\n    show: true,\n    /* \n      支持哪些语言切换\n      v1.x 版本包括：de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr \n      v2.x 版本根据后端翻译服务不同，支持的语言也不同。具体支持哪些，可通过 http://api.translate.zvo.cn/doc/language.json.html 获取 （如果您私有部署的，将请求域名换为您自己私有部署的域名）\n    */\n    languages: '',\n    alreadyRender: false,\n    //当前是否已渲染过了 true为是 v2.2增加\n    selectOnChange: function (event) {\n      var language = event.target.value;\n      translate.changeLanguage(language);\n    },\n    render: function () {\n      //v2增加\n      if (translate.selectLanguageTag.alreadyRender) {\n        return;\n      }\n      translate.selectLanguageTag.alreadyRender = true;\n\n      //判断如果不显示select选择语言，直接就隐藏掉\n      if (!translate.selectLanguageTag.show) {\n        return;\n      }\n\n      //判断translate 的id是否存在，不存在就创建一个\n      if (document.getElementById('translate') == null) {\n        var body_trans = document.getElementsByTagName('body')[0];\n        var div = document.createElement(\"div\"); //创建一个script标签\n        div.id = \"translate\";\n        body_trans.appendChild(div);\n      } else {\n        //存在，那么判断一下 select是否存在，要是存在就不重复创建了\n        if (document.getElementById('translateSelectLanguage') != null) {\n          //select存在了，就不重复创建了\n          return;\n        }\n      }\n\n      //从服务器加载支持的语言库\n      translate.request.post(translate.request.api.host + translate.request.api.language + '?v=' + translate.version, {}, function (data) {\n        if (data.result == 0) {\n          console.log('load language list error : ' + data.info);\n          return;\n        }\n\n        //select的onchange事件\n        var onchange = function (event) {\n          translate.selectLanguageTag.selectOnChange(event);\n        };\n\n        //创建 select 标签\n        var selectLanguage = document.createElement(\"select\");\n        selectLanguage.id = 'translateSelectLanguage';\n        selectLanguage.className = 'translateSelectLanguage';\n        for (var i = 0; i < data.list.length; i++) {\n          var option = document.createElement(\"option\");\n          option.setAttribute(\"value\", data.list[i].id);\n\n          //判断 selectLanguageTag.languages 中允许使用哪些\n\n          if (translate.selectLanguageTag.languages.length > 0) {\n            //设置了自定义显示的语言\n\n            //都转小写判断\n            var langs_indexof = (',' + translate.selectLanguageTag.languages + ',').toLowerCase();\n            console.log(langs_indexof);\n            if (langs_indexof.indexOf(',' + data.list[i].id.toLowerCase() + ',') < 0) {\n              //没发现，那不显示这个语种，调出\n              continue;\n            }\n          }\n\n          /*判断默认要选中哪个语言*/\n          if (translate.to != null && typeof translate.to != 'undefined' && translate.to.length > 0) {\n            //设置了目标语言，那就进行判断显示目标语言\n\n            if (translate.to == data.list[i].id) {\n              option.setAttribute(\"selected\", 'selected');\n            }\n          } else {\n            //没设置目标语言，那默认选中当前本地的语种\n            if (data.list[i].id == translate.language.getLocal()) {\n              option.setAttribute(\"selected\", 'selected');\n            }\n          }\n          option.appendChild(document.createTextNode(data.list[i].name));\n          selectLanguage.appendChild(option);\n        }\n        //增加 onchange 事件\n        if (window.addEventListener) {\n          // Mozilla, Netscape, Firefox \n          selectLanguage.addEventListener('change', onchange, false);\n        } else {\n          // IE \n          selectLanguage.attachEvent('onchange', onchange);\n        }\n        //将select加入进网页显示\n        document.getElementById('translate').appendChild(selectLanguage);\n        /*\n        try{\n          document.getElementById('translateSelectLanguage').style.width = '94px';\n        }catch(e){ console.log(e);} \n        */\n      });\n    }\n  },\n  /*\n   * 当前本地语言\n   */\n  //localLanguage:'zh-CN',\n  localLanguage: 'zh-CN',\n  /**\n   * google翻译执行的\n   */\n  googleTranslateElementInit: function () {\n    var selectId = '';\n    if (document.getElementById('translate') != null) {\n      // && document.getElementById('translate').innerHTML.indexOf('translateSelectLanguage') > 0\n      //已经创建过了,存在\n      selectId = 'translate';\n    }\n    translate.translate = new google.translate.TranslateElement({\n      //这参数没用，请忽略\n      pageLanguage: 'zh-CN',\n      //一共80种语言选择，这个是你需要翻译的语言，比如你只需要翻译成越南和英语，这里就只写en,vi\n      //includedLanguages: 'de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr',\n      includedLanguages: translate.selectLanguageTag.languages,\n      //选择语言的样式，这个是面板，还有下拉框的样式，具体的记不到了，找不到api~~  \n      layout: 0\n      //自动显示翻译横幅，就是翻译后顶部出现的那个，有点丑，设置这个属性不起作用的话，请看文章底部的其他方法\n      //autoDisplay: false, \n      //disableAutoTranslation:false,\n      //还有些其他参数，由于原插件不再维护，找不到详细api了，将就了，实在不行直接上dom操作\n    }, selectId //触发按钮的id\n    );\n  },\n  /**\n   * 初始化，如加载js、css资源\n   */\n  init: function () {\n    /****** 先判断当前协议，定义资源路径  ******/\n    var protocol = window.location.protocol;\n    if (window.location.protocol == 'file:') {\n      //本地的，那就用http\n      protocol = 'http:';\n    }\n    if (this.resourcesUrl.indexOf('://') == -1) {\n      //还没设置过，进行设置\n      this.resourcesUrl = protocol + this.resourcesUrl;\n    }\n\n    //this.resourcesUrl = 'file://G:/git/translate';\n  },\n  /**\n   * 执行翻译操作\n   */\n  execute_v1: function () {\n    /*********** 判断translate 的id是否存在，不存在就创建一个  */\n    if (document.getElementById('translate') == null) {\n      if (translate.selectLanguageTag.show) {\n        var body_trans = document.getElementsByTagName('body')[0];\n        var div = document.createElement(\"div\"); //创建一个script标签\n        div.id = \"translate\";\n        body_trans.appendChild(div);\n      }\n    }\n\n    /* 处理1.0 - 1.1 升级的 */\n    if (translate.includedLanguages == '') {\n      //如果未设置，用默认的\n      translate.selectLanguageTag.languages = translate.includedLanguages;\n    }\n    /* 用户1.0版本设置过这个，那么就以这个为主 */\n    console.log('translate.js tip: translate.includedLanguages obsolete, please use the translate.selectLanguageTag.languages are set');\n\n    /****** 先加载资源  ******/\n    var head0 = document.getElementsByTagName('head')[0];\n    var script = document.createElement(\"script\"); //创建一个script标签\n    script.type = \"text/javascript\";\n    //script.async = true;\n    script.src = this.resourcesUrl + '/js/element.js';\n    head0.appendChild(script);\n  },\n  /**\n   * 设置Cookie，失效时间一年。\n   * @param name\n   * @param value\n   */\n  setCookie: function (name, value) {\n    var cookieString = name + \"=\" + escape(value);\n    document.cookie = cookieString;\n  },\n  //获取Cookie。若是不存再，返回空字符串\n  getCookie: function (name) {\n    var strCookie = document.cookie;\n    var arrCookie = strCookie.split(\"; \");\n    for (var i = 0; i < arrCookie.length; i++) {\n      var arr = arrCookie[i].split(\"=\");\n      if (arr[0] == name) {\n        return unescape(arr[1]);\n      }\n    }\n    return \"\";\n  },\n  /**\n   * 获取当前页面采用的是什么语言\n   * 返回值如 en、zh-CN、zh-TW （如果是第一次用，没有设置过，那么返回的是 translate.localLanguage 设置的值）\t\t\n   */\n  currentLanguage: function () {\n    //translate.check();\n    var cookieValue = translate.getCookie('googtrans');\n    if (cookieValue.length > 0) {\n      return cookieValue.substr(cookieValue.lastIndexOf('/') + 1, cookieValue.length - 1);\n    } else {\n      return translate.localLanguage;\n    }\n  },\n  /**\n   * 切换语言，比如切换为英语、法语\n     * @param languageName 要切换的语言语种。传入如 en、zh-CN\n   * \t\t\t\t会自动根据传入的语言来判断使用哪种版本。比如传入 en、zh-CN 等，则会使用v1.x版本\n   * \t\t\t\t\t\t\t\t\t\t\t\t\t\t传入 chinese_simplified 、english 等，则会使用 v2.x版本\n   */\n  changeLanguage: function (languageName) {\n    //判断使用的是否是v1.x\n    var v1 = ',en,de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr,';\n    if (v1.indexOf(',' + languageName + ',') > -1) {\n      //用的是v1.x\n      console.log('您使用的是v1版本的切换语种方式，v1已在2021年就以废弃，请更换为v2，参考文档： http://translate.zvo.cn/41549.html');\n      translate.check();\n      var googtrans = '/' + translate.localLanguage + '/' + languageName;\n\n      //先清空泛解析域名的设置\n      var s = document.location.host.split('.');\n      if (s.length > 2) {\n        var fanDomain = s[s.length - 2] + '.' + s[s.length - 1];\n        document.cookie = 'googtrans=;expires=' + new Date(1) + ';domain=' + fanDomain + ';path=/';\n        document.cookie = 'googtrans=' + googtrans + ';domain=' + fanDomain + ';path=/';\n      }\n      translate.setCookie('googtrans', '' + googtrans);\n      location.reload();\n      return;\n    }\n\n    //用的是v2.x或更高\n    translate.setUseVersion2();\n    //判断是否是第一次翻译，如果是，那就不用刷新页面了。 true则是需要刷新，不是第一次翻译\n    if (translate.to != null && translate.to.length > 0) {\n      //当前目标值有值，且目标语言跟当前语言不一致，那当前才是已经被翻译过的\n      if (translate.to != translate.language.getLocal()) {\n        var isReload = true; //标记要刷新页面\n      }\n    }\n    translate.to = languageName;\n    translate.storage.set('to', languageName); //设置目标翻译语言\n\n    if (isReload) {\n      location.reload(); //刷新页面\n    } else {\n      //不用刷新，直接翻译\n      translate.execute(); //翻译\n    }\n  },\n  /**\n   * 自检提示，适用于 v1.x， 在 v2.x中已废弃\n   */\n  check: function () {\n    if (window.location.protocol == 'file:') {\n      console.log('\\r\\n---WARNING----\\r\\ntranslate.js 主动翻译组件自检异常，当前协议是file协议，翻译组件要在正常的线上http、https协议下才能正常使用翻译功能\\r\\n------------');\n    }\n  },\n  /**************************** v2.0 */\n  to: '',\n  //翻译为的目标语言，如 english 、chinese_simplified\n  //用户第一次打开网页时，自动判断当前用户所在国家使用的是哪种语言，来自动进行切换为用户所在国家的语种。\n  //如果使用后，第二次在用，那就优先以用户所选择的为主，这个就不管用了\n  //默认是false，不使用，可设置true：使用\n  //使用 setAutoDiscriminateLocalLanguage 进行设置\n  autoDiscriminateLocalLanguage: false,\n  documents: [],\n  //指定要翻译的元素的集合,可设置多个，如设置： document.getElementsByTagName('DIV')\n  //翻译时忽略的一些东西，比如忽略某个tag、某个class等\n  ignore: {\n    tag: ['style', 'script', 'link', 'pre', 'code'],\n    class: ['ignore', 'translateSelectLanguage'],\n    id: [],\n    /*\n      传入一个元素，判断这个元素是否是被忽略的元素。 这个会找父类，看看父类中是否包含在忽略的之中。\n      return true是在忽略的之中，false不再忽略的之中\n    */\n    isIgnore: function (ele) {\n      if (ele == null || typeof ele == 'undefined') {\n        return false;\n      }\n      var parentNode = ele;\n      var maxnumber = 100; //最大循环次数，避免死循环\n      while (maxnumber-- > 0) {\n        if (parentNode == null || typeof parentNode == 'undefined') {\n          //没有父元素了\n          return false;\n        }\n\n        //判断Tag\n        //var tagName = parentNode.nodeName.toLowerCase(); //tag名字，小写\n        var nodename = translate.element.getNodeName(parentNode).toLowerCase(); //tag名字，小写\n        if (nodename.length > 0) {\n          //有nodename\n          if (nodename == 'body' || nodename == 'html' || nodename == '#document') {\n            //上层元素已经是顶级元素了，那肯定就不是了\n            return false;\n          }\n          if (translate.ignore.tag.indexOf(nodename) > -1) {\n            //发现ignore.tag 当前是处于被忽略的 tag\n            return true;\n          }\n        }\n\n        //判断class name\n        if (parentNode.className != null) {\n          var classNames = parentNode.className;\n          if (classNames == null || typeof classNames != 'string') {\n            continue;\n          }\n          //console.log('className:'+typeof(classNames));\n          //console.log(classNames);\n          classNames = classNames.trim().split(' ');\n          for (var c_index = 0; c_index < classNames.length; c_index++) {\n            if (classNames[c_index] != null && classNames[c_index].trim().length > 0) {\n              //有效的class name，进行判断\n              if (translate.ignore.class.indexOf(classNames[c_index]) > -1) {\n                //发现ignore.class 当前是处于被忽略的 class\n                return true;\n              }\n            }\n          }\n        }\n\n        //判断id\n        if (parentNode.id != null && typeof parentNode.id != 'undefined') {\n          //有效的class name，进行判断\n          if (translate.ignore.id.indexOf(parentNode.id) > -1) {\n            //发现ignore.id 当前是处于被忽略的 id\n            return true;\n          }\n        }\n\n        //赋予判断的元素向上一级\n        parentNode = parentNode.parentNode;\n      }\n      return false;\n    }\n  },\n  //自定义翻译术语\n  nomenclature: {\n    /*\n      术语表\n      一维：要转换的语种，如 english\n      二维：翻译至的目标语种，如 english\n      三维：要转换的字符串，如 \"你好\"\n      结果：自定义的翻译结果，如 “Hallo”\n    */\n    data: new Array(),\n    /*\n      原始术语表，可编辑的\n      一维：要自定义目标词\n      二维：针对的是哪个语种\n      值：要翻译为什么内容\n       其设置如 \n      var data = new Array();\n      data['版本'] = {\n        english : 'banben',\n        korean : 'BanBen'\n      };\n      data['国际化'] = {\n        english : 'guojihua',\n        korean : 'GuoJiHua'\n      };\n    \t\n      【已过时】\n    */\n    old_Data: [],\n    /*\n    set:function(data){\n      translate.nomenclature.data = data;\n    },\n    */\n    set: function (data) {\n      alert('请将 translate.nomenclature.set 更换为 append，具体使用可参考： https://github.com/xnx3/translate ');\n    },\n    /*\n      向当前术语库中追加自定义术语。如果追加的数据重复，会自动去重\n      传入参数：\n        from 要转换的语种\n        to 翻译至的目标语种\n        properties 属于配置表，格式如：\n            你好=Hello\n            世界=ShiJie\n     */\n    append: function (from, to, properties) {\n      if (typeof translate.nomenclature.data[from] == 'undefined') {\n        translate.nomenclature.data[from] = new Array();\n      }\n      if (typeof translate.nomenclature.data[from][to] == 'undefined') {\n        translate.nomenclature.data[from][to] = new Array();\n      }\n\n      //将properties进行分析\n      //按行拆分\n      var line = properties.split('\\n');\n      //console.log(line)\n      for (var line_index = 0; line_index < line.length; line_index++) {\n        var item = line[line_index].trim();\n        if (item.length < 1) {\n          //空行，忽略\n          continue;\n        }\n        var kvs = item.split('=');\n        //console.log(kvs)\n        if (kvs.length != 2) {\n          //不是key、value构成的，忽略\n          continue;\n        }\n        var key = kvs[0].trim();\n        var value = kvs[1].trim();\n        //console.log(key)\n        if (key.length == 0 || value.length == 0) {\n          //其中某个有空，则忽略\n          continue;\n        }\n\n        //加入，如果之前有加入，则会覆盖\n        translate.nomenclature.data[from][to][key] = value;\n        //console.log(local+', '+target+', key:'+key+', value:'+value);\n      }\n\n      //追加完后，对整个对象数组进行排序，key越大越在前面\n      translate.nomenclature.data[from][to] = translate.util.objSort(translate.nomenclature.data[from][to]);\n    },\n    //获取当前定义的术语表\n    get: function () {\n      return translate.nomenclature.data;\n    },\n    //对传入的str字符进行替换，将其中的自定义术语提前进行替换，然后将替换后的结果返回\n    dispose: function (str) {\n      if (str == null || str.length == 0) {\n        return str;\n      }\n      //if(translate.nomenclature.data.length == 0){\n      //\treturn str;\n      //}\n      //判断当前翻译的两种语种是否有自定义术语库\n      //console.log(typeof(translate.nomenclature.data[translate.language.getLocal()][translate.to]))\n      if (typeof translate.nomenclature.data[translate.language.getLocal()] == 'undefined' || typeof translate.nomenclature.data[translate.language.getLocal()][translate.to] == 'undefined') {\n        return str;\n      }\n      //console.log(str)\n      for (var originalText in translate.nomenclature.data[translate.language.getLocal()][translate.to]) {\n        var translateText = translate.nomenclature.data[translate.language.getLocal()][translate.to][originalText];\n        if (typeof translateText == 'function') {\n          //进行异常的预处理调出\n          continue;\n        }\n        var index = str.indexOf(originalText);\n        if (index > -1) {\n          //console.log('find -- '+originalText+', \\t'+translateText);\n          if (translate.language.getLocal() == 'english') {\n            //如果本地语种是英文，那么还要判断它的前后，避免比如要替换 is 将 display 中的is给替换，将单词给强行拆分了\n\n            //判断这个词前面是否符合\n            var beforeChar = ''; //前面的字符\n            if (index == 0) {\n              //前面没别的字符了，那前面合适\n            } else {\n              //前面有别的字符,判断是什么字符，如果是英文，那么这个是不能被拆分的，要忽略\n              beforeChar = str.substr(index - 1, 1);\n              //console.log('beforeChar:'+beforeChar+', str:'+str)\n              var lang = translate.language.getCharLanguage(beforeChar);\n              //console.log(lang);\n              if (lang == 'english') {\n                //调出，不能强拆\n                continue;\n              }\n            }\n\n            //判断这个词的后面是否符合\n            var afterChar = ''; //后面的字符\n            if (index + originalText.length == str.length) {\n              //后面没别的字符了，那前面合适\n              //console.log(originalText+'， meile '+str)\n            } else {\n              //后面有别的字符,判断是什么字符，如果是英文，那么这个是不能被拆分的，要忽略\n              afterChar = str.substr(index + originalText.length, 1);\n              var lang = translate.language.getCharLanguage(afterChar);\n              if (lang == 'english') {\n                //跳出，不能强拆\n                continue;\n              }\n            }\n            str = str.replace(new RegExp(beforeChar + originalText + afterChar, 'g'), beforeChar + translateText + afterChar);\n          } else {\n            //其他情况，如汉语、汉语等语种\n            str = str.replace(new RegExp(originalText, 'g'), translateText);\n          }\n        }\n      }\n      return str;\n\n      /*\n      //遍历一维\n      for(var originalText in translate.nomenclature.data){\n        var languageResult = translate.nomenclature.data[originalText];\n        if(typeof(languageResult) == 'function'){\n          //进行异常的预处理调出\n          continue;\n        }\n         if(typeof(languageResult[translate.to]) == 'undefined'){\n          //console.log('und');\n          continue;\n        }\n         //var hash = translate.util.hash(originalText);\n         //console.log(originalText+',\\t'+str);\n        if(str.indexOf(originalText) > -1){\n          //console.log('find -- '+originalText+', \\t'+languageResult[translate.to]);\n          str = str.replace(new RegExp(originalText,'g'),languageResult[translate.to]);\n        }\n      }\n          \t\n      return str;\n      */\n    }\n  },\n  office: {\n    /*\n      网页上翻译之后，自动导出当前页面的术语库\n    \t\n      需要先指定本地语种，会自动将本地语种进行配置术语库\n    \t\n    */\n    export: function () {\n      if (translate.language.getLocal() == translate.language.getCurrent()) {\n        alert('本地语种跟要翻译的语种一致，无需导出');\n        return;\n      }\n      var text = '';\n      for (var uuid in translate.nodeQueue) {\n        var queueValue = translate.nodeQueue[uuid];\n        for (var lang in translate.nodeQueue[uuid].list) {\n          //console.log('------'+lang)\n          if (typeof lang != 'string' || lang.length < 1) {\n            continue;\n          }\n          //if(translate.language.getLocal() == lang){\n          //console.log(translate.nodeQueue[uuid].list[lang]);\n          for (var hash in translate.nodeQueue[uuid].list[lang]) {\n            //console.log(translate.nodeQueue[uuid].list[lang][hash].original);\n            //console.log(translate.nodeQueue[uuid].list[lang][hash].original);\n            text = text + '\\n' + translate.nodeQueue[uuid].list[lang][hash].original + '=' + translate.storage.get('hash_' + translate.language.getCurrent() + '_' + hash);\n          }\n          //}\n        }\n      }\n      if (text.length > 0) {\n        //有内容\n        text = 'translate.office.append(\\'' + translate.language.getCurrent() + '\\',`' + text + '\\n`);';\n        //console.log(text);\n        translate.util.loadMsgJs();\n        msg.popups({\n          text: '<textarea id=\"msgPopupsTextarea\" style=\"width:100%; height:100%;\">loaing...</textarea>',\n          width: '750px',\n          height: '600px',\n          padding: '1px'\n        });\n        document.getElementById('msgPopupsTextarea').value = text;\n      } else {\n        msg.alert('无有效内容');\n      }\n    },\n    //显示导出面板\n    showPanel: function () {\n      let panel = document.createElement('div');\n      panel.setAttribute('id', 'translate_export');\n      panel.setAttribute('class', 'ignore');\n\n      //导出按钮\n      let button = document.createElement('button');\n      button.onclick = function () {\n        translate.office.export();\n      };\n      button.innerHTML = '导出配置信息';\n      button.setAttribute('style', 'margin-left: 72px; margin-top: 30px; margin-bottom: 20px; font-size: 25px;');\n      panel.appendChild(button);\n\n      //说明文字\n      let textdiv = document.createElement('div');\n      textdiv.innerHTML = '1. 首先将当前语种切换为你要翻译的语种<br/>2. 点击导出按钮，将翻译的配置信息导出<br/>3. 将导出的配置信息粘贴到代码中，即可完成<br/><a href=\"asd\" target=\"_black\" style=\"color: aliceblue;\">点此进行查阅详细使用说明</a>';\n      textdiv.setAttribute('style', 'font-size: 14px; padding: 12px;');\n      panel.appendChild(textdiv);\n      panel.setAttribute('style', 'background-color: black; color: #fff; width: 320px; height: 200px; position: fixed; bottom: 50px; right: 50px;');\n      //把元素节点添加到body元素节点中成为其子节点，放在body的现有子节点的最后\n      document.body.appendChild(panel);\n      translate.util.loadMsgJs();\n    },\n    /*\n      追加离线翻译数据。如果追加的数据重复，会自动去重\n      传入参数：\n        from 要转换的语种\n        to 翻译至的目标语种\n        properties 属于配置表，格式如：\n            你好=Hello\n            世界=ShiJie\n      这个传入参数跟 translate.nomenclature.append 的传入参数格式是一致的\t\t\t\n    */\n    append: function (to, properties) {\n      //console.log(properties)\n      //将properties进行分析\n      //按行拆分\n      var line = properties.split('\\n');\n      //console.log(line)\n      for (var line_index = 0; line_index < line.length; line_index++) {\n        var item = line[line_index].trim();\n        if (item.length < 1) {\n          //空行，忽略\n          continue;\n        }\n        var kvs = item.split('=');\n        //console.log(kvs)\n        if (kvs.length != 2) {\n          //不是key、value构成的，忽略\n          continue;\n        }\n        var key = kvs[0];\n        var value = kvs[1];\n        //console.log(key)\n        if (key.length == 0 || value.length == 0) {\n          //其中某个有空，则忽略\n          continue;\n        }\n        //console.log('set---'+key);\n        //加入 storate\n        translate.storage.set('hash_' + to + '_' + translate.util.hash(key), value);\n      }\n    }\n  },\n  setAutoDiscriminateLocalLanguage: function () {\n    translate.autoDiscriminateLocalLanguage = true;\n  },\n  /*\n    待翻译的页面的node队列\n    一维：key:uuid，也就是execute每次执行都会创建一个翻译队列，这个是翻译队列的唯一标识。   \n       value:\n        k/v \n    二维：对象形态，具体有：\n       key:expireTime 当前一维数组key的过期时间，到达过期时间会自动删除掉这个一维数组。如果<0则代表永不删除，常驻内存\n       value:list 待翻译的页面的node队列\n    三维：针对二维的value，  key:english、chinese_simplified等语种，这里的key便是对value的判断，取value中的要翻译的词是什么语种，对其进行了语种分类    value: k/v\n    四维：针对三维的value，  key:要翻译的词（经过语种分割的）的hash，   value: node数组\n    五维：针对四维的value，  这是个对象， 其中\n        original: 是三维的key的hash的原始文字，也就是 node 中的原始文字。\n        cacheHash: 如果翻译时匹配到了自定义术语库中的词，那么翻译完后存入到缓存中时，其缓存的翻译前字符串已经不是original，二是匹配完术语库后的文本的hash了。所以这里额外多增加了这个属性。如果匹配了术语库，那这里就是要进行缓存的翻译前文本的hash，如果未使用术语库，这里就跟其key-hash 相同。\n        translateText: 针对 original 的经过加工过的文字，比如经过自定义术语操作后的，待翻译的文字。\n        nodes: 有哪些node元素中包含了这个词，都会在这里记录\n        beforeText: node元素中进行翻译结果赋予时，额外在翻译结果的前面加上的字符串。其应用场景为，如果中英文混合场景下，避免中文跟英文挨着导致翻译为英语后，连到一块了。默认是空字符串 ''\n        afterText:  node元素中进行翻译结果赋予时，额外在翻译结果的后面加上的字符串。其应用场景为，如果中英文混合场景下，避免中文跟英文挨着导致翻译为英语后，连到一块了。默认是空字符串 ''\n    六维：针对五维的 nodes，将各个具体的 node 以及 其操作的 attribute 以数组形式列出\n    七维：针对六维列出的nodes数组，其中包含：\n        node: 具体操作的node元素\n        attribute: 也就是翻译文本针对的是什么，是node本身（nodeValue），还是 node 的某个属性，比如title属性，这则是设置为 \"title\"。如果这里不为空，那就是针对的属性操作的。 如果这里为空或者undefined ，那就是针对node本身，也就是 nodeValue 的字符串操作的\n  \t\n    生命周期： 当execute()执行时创建，  当execute结束（其中的所有request接收到响应并渲染完毕）时销毁（当前暂时不销毁，以方便调试）\n  */\n  nodeQueue: {},\n  //指定要翻译的元素的集合,可传入一个元素或多个元素\n  //如设置一个元素，可传入如： document.getElementsById('test')\n  //如设置多个元素，可传入如： document.getElementsByTagName('DIV')\n  setDocuments: function (documents) {\n    if (documents == null || typeof documents == 'undefined') {\n      return;\n    }\n    if (typeof documents.length == 'undefined') {\n      //不是数组，是单个元素\n      translate.documents[0] = documents;\n    } else {\n      //是数组，直接赋予\n      translate.documents = documents;\n    }\n    //清空翻译队列，下次翻译时重新检索\n    translate.nodeQueue = {};\n    console.log('set documents , clear translate.nodeQueue');\n  },\n  //获取当前指定翻译的元素（数组形式 [document,document,...]）\n  //如果用户未使用setDocuments 指定的，那么返回整个网页\n  getDocuments: function () {\n    if (translate.documents != null && typeof translate.documents != 'undefined' && translate.documents.length > 0) {\n      // setDocuments 指定的\n      return translate.documents;\n    } else {\n      //未使用 setDocuments指定，那就是整个网页了\n      return document.all; //翻译所有的\n    }\n  },\n  listener: {\n    //当前页面打开后，是否已经执行完execute() 方法进行翻译了，只要执行完一次，这里便是true。 （多种语言的API请求完毕并已渲染html）\n    isExecuteFinish: false,\n    //是否已经使用了 translate.listener.start() 了，如果使用了，那这里为true，多次调用 translate.listener.start() 只有第一次有效\n    isStart: false,\n    //translate.listener.start();\t//开启html页面变化的监控，对变化部分会进行自动翻译。注意，这里变化区域，是指使用 translate.setDocuments(...) 设置的区域。如果未设置，那么为监控整个网页的变化\n    start: function () {\n      translate.temp_linstenerStartInterval = setInterval(function () {\n        if (document.readyState == 'complete') {\n          //dom加载完成，进行启动\n          clearInterval(translate.temp_linstenerStartInterval); //停止\n          translate.listener.addListener();\n        }\n\n        //if(translate.listener.isExecuteFinish){ //执行完过一次，那才能使用\n        /*if(translate.listener.isStart){\n          //已开启了\n          return;\n        }*/\n\n        //console.log('translate.temp_linstenerStartInterval Finish!');\n        //}\n      }, 50);\n\n      //\twindow.onload = function(){\n      /* if(translate.listener.isStart){\n        //已开启了\n        return;\n      } */\n\n      //判断是否是执行完一次了\n      //        translate.temp_linstenerStartInterval = setInterval(function(){\n      //if(translate.listener.isExecuteFinish){ //执行完过一次，那才能使用\n      /*if(translate.listener.isStart){\n        //已开启了\n        return;\n      }*/\n      //\t\t\t\tclearInterval(translate.temp_linstenerStartInterval);//停止\n      //\t\t\t\ttranslate.listener.addListener();\n      //console.log('translate.temp_linstenerStartInterval Finish!');\n      //}\n      //\t      }, 50);\n      //\t}\n    },\n    //增加监听，开始监听。这个不要直接调用，需要使用上面的 start() 开启\n    addListener: function () {\n      translate.listener.isStart = true; //记录已执行过启动方法了\n\n      // 观察器的配置（需要观察什么变动）\n      const config = {\n        attributes: true,\n        childList: true,\n        subtree: true\n      };\n      // 当观察到变动时执行的回调函数\n      const callback = function (mutationsList, observer) {\n        var documents = []; //有变动的元素\n\n        // Use traditional 'for loops' for IE 11\n        for (let mutation of mutationsList) {\n          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n            //多了个组件\n            documents.push.apply(documents, mutation.addedNodes);\n            //    console.log(mutation.addedNodes);\n            //}else if (mutation.type === 'attributes') {\n            //   console.log('The ' + mutation.attributeName + ' attribute was modified.');\n          }\n        }\n\n        //console.log(documents);\n        if (documents.length > 0) {\n          //有变动，需要看看是否需要翻译\n          translate.execute(documents); //指定要翻译的元素的集合,可传入一个或多个元素。如果不设置，默认翻译整个网页\n        }\n      };\n      // 创建一个观察器实例并传入回调函数\n      const observer = new MutationObserver(callback);\n      // 以上述配置开始观察目标节点\n      var docs = translate.getDocuments();\n      for (var docs_index = 0; docs_index < docs.length; docs_index++) {\n        var doc = docs[docs_index];\n        if (doc != null) {\n          observer.observe(doc, config);\n        }\n      }\n    },\n    /*\n      每当执行完一次渲染任务（翻译）时会触发此。注意页面一次翻译会触发多个渲染任务。普通情况下，一次页面的翻译可能会触发两三次渲染任务。\n      另外如果页面中有ajax交互方面的信息，时，每次ajax信息刷新后，也会进行翻译，也是一次渲染任务。\n      这个是为了方便扩展使用。比如在layui中扩展，监控 select 的渲染\n    */\n    renderTaskFinish: function (renderTask) {\n      //console.log(renderTask);\n    }\n  },\n  //对翻译结果进行替换渲染的任务，将待翻译内容替换为翻译内容的过程\n  renderTask: class {\n    constructor() {\n      /*\n       * 任务列表\n       * 一维数组 [hash] = tasks;  tasks 是多个task的数组集合\n       * 二维数组 [task,task,...]，存放多个 task，每个task是一个替换。这里的数组是同一个nodeValue的多个task替换\n       * 三维数组 task['originalText'] 、 task['resultText'] 存放要替换的字符串\n               task['attribute'] 存放要替换的属性，比如 a标签的title属性。 如果是直接替换node.nodeValue ，那这个没有\n       */\n      this.taskQueue = [];\n\n      /*\n       * 要进行翻译的node元素，\n       * 一维数组 key:node.nodeValue 的 hash ， value:node的元素数组\n       * 二维数组，也就是value中包含的node集合 [node,node,...]\n         */\n      this.nodes = [];\n    }\n\n    /**\n     * 向替换队列中增加替换任务\n     * node:要替换的字符属于那个node元素\n     * originalText:待翻译的字符\n     * resultText:翻译后的结果字符\n     * attribute: 要替换的是哪个属性，比如 a标签的title属性，这里便是传入title。如果不是替换属性，这里不用传入，或者传入null\n     */\n    add(node, originalText, resultText, attribute) {\n      var nodeAnaly = translate.element.nodeAnalyse.get(node, attribute); //node解析\n      //var hash = translate.util.hash(translate.element.getTextByNode(node)); \t//node中内容的hash\n      var hash = translate.util.hash(nodeAnaly['text']);\n      //console.log('--------------'+hash);\n      //console.log(nodeAnaly);\n      //console.log(node);\n      //console.log('originalText:'+originalText+', resultText:'+resultText+', attribute:'+attribute);\n      /****** 加入翻译的元素队列  */\n      if (typeof this.nodes[hash] == 'undefined') {\n        this.nodes[hash] = new Array();\n      }\n      this.nodes[hash].push(node);\n      //console.log(node)\n\n      /****** 加入翻译的任务队列  */\n      var tasks = this.taskQueue[hash];\n      if (tasks == null || typeof tasks == 'undefined') {\n        //console.log(node.nodeValue);\n        tasks = new Array(); //任务列表，存放多个 task，每个task是一个替换。这里的数组是同一个nodeValue的多个task替换\n      }\n      var task = new Array();\n\n      //v2.3.3 增加 -- 开始\n      //这里要进行处理，因为有时候翻译前，它前或者后是有空格的，但是翻译后会把前或者后的空格给自动弄没了，如果是这种情况，要手动补上\n      if (originalText.substr(0, 1) == ' ') {\n        //console.log('第一个字符是空格');\n        if (resultText.substr(0, 1) != ' ') {\n          //翻译结果的第一个字符不是空格，那么补上\n          resultText = ' ' + resultText;\n        }\n      }\n      if (originalText.substr(originalText.length - 1, 1) === ' ') {\n        //console.log('最后一个字符是空格');\n        if (resultText.substr(0, 1) != ' ') {\n          //翻译结果的最后一个字符不是空格，那么补上\n          resultText = resultText + ' ';\n        }\n      }\n      //v2.3.3 增加 -- 结束\n\n      task['originalText'] = originalText;\n      task['resultText'] = resultText;\n      task['attribute'] = attribute;\n\n      //console.log(task);\n      tasks.push(task);\n      this.taskQueue[hash] = tasks;\n      /****** 加入翻译的任务队列 end  */\n    }\n    //进行替换渲染任务，对页面进行渲染替换翻译\n    execute() {\n      //先对tasks任务队列的替换词进行排序，将同一个node的替换词有大到小排列，避免先替换了小的，大的替换时找不到\n      for (var hash in this.taskQueue) {\n        var tasks = this.taskQueue[hash];\n        if (typeof tasks == 'function') {\n          //进行异常的预处理调出\n          continue;\n        }\n\n        //进行排序,将原字符串长的放前面，避免造成有部分不翻译的情况（bug是先翻译了短的，导致长的被打断而无法进行适配）\n        tasks.sort((a, b) => b.originalText.length - a.originalText.length);\n        this.taskQueue[hash] = tasks;\n      }\n\n      //console.log('===========task=========');\n      //console.log(this.taskQueue);\n      //console.log(this.nodes);\n      //console.log('===========task======end===');\n\n      //对nodeQueue进行翻译\n      for (var hash in this.nodes) {\n        var tasks = this.taskQueue[hash]; //取出当前node元素对应的替换任务\n        //var tagName = this.nodes[hash][0].nodeName; //以下节点的tag name\n        //console.log(tasks);\n        for (var node_index = 0; node_index < this.nodes[hash].length; node_index++) {\n          //对这个node元素进行替换翻译字符\n          for (var task_index = 0; task_index < tasks.length; task_index++) {\n            var task = tasks[task_index];\n            if (typeof tasks == 'function') {\n              //进行异常的预处理调出\n              continue;\n            }\n\n            //console.log(this.nodes[hash][task_index]);\n            translate.element.nodeAnalyse.set(this.nodes[hash][task_index], task.originalText, task.resultText, task['attribute']);\n            /*\n            //var tagName = translate.element.getTagNameByNode(this.nodes[hash][task_index]);//节点的tag name\n            //console.log(tagName)\n            //console.log(this.nodes[hash][task_index])\n            //var tagName = this.nodes[hash][task_index].nodeName; //节点的tag name\n            var nodename = translate.element.getNodeName(this.nodes[hash][task_index]);\n                        //console.log(this.nodes[hash][task_index]+', '+task.originalText+', '+task.resultText+', tagName:'+tagName);\n            if(nodename == 'META'){\n              if(typeof(this.nodes[hash][task_index].name) != 'undefined' && this.nodes[hash][task_index].name != null){\n                //var nodeName = this.nodes[hash][task_index].name.toLowerCase();  //取meta 标签的name 属性\n              \t\n                this.nodes[hash][task_index].content = this.nodes[hash][task_index].content.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n              }\n            }else if(nodename == 'IMG'){\n              this.nodes[hash][task_index].alt = this.nodes[hash][task_index].alt.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            }else{\n              //普通的\n              //console.log('task.originalText : '+task.originalText);\n              //console.log(translate.util.regExp.pattern(task.originalText))\n              //console.log('task.resultText : '+task.resultText);\n              this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            }\n            */\n          }\n        }\n      }\n\n      //监听\n      if (typeof this.taskQueue != 'undefined' && this.taskQueue.length > 0) {\n        translate.listener.renderTaskFinish(this);\n      }\n    }\n  },\n  //执行翻译操作。翻译的是 nodeQueue 中的\n  //docs 如果传入，那么翻译的只是传入的这个docs的。传入如 [document.getElementById('xxx'),document.getElementById('xxx'),...]\n  execute: function (docs) {\n    if (typeof doc != 'undefined') {\n      //execute传入参数，只有v2版本才支持\n      translate.useVersion = 'v2';\n    }\n    if (translate.useVersion == 'v1') {\n      //if(this.to == null || this.to == ''){\n      //采用1.x版本的翻译，使用google翻译\n      //translate.execute_v1();\n      //return;\n      //v2.5.1增加\n      console.log('提示：https://github.com/xnx3/translate 在 v2.5 版本之后，由于谷歌翻译调整，免费翻译通道不再支持，所以v1版本的翻译接口不再被支持，v1全线下架。考虑到v1已不能使用，当前已自动切换到v2版本。如果您使用中发现什么异常，请针对v2版本进行适配。');\n      translate.useVersion = 'v2';\n    }\n\n    /****** 采用 2.x 版本的翻译，使用自有翻译算法 */\n\n    //每次执行execute，都会生成一个唯一uuid，也可以叫做队列的唯一标识，每一次执行execute都会创建一个独立的翻译执行队列\n    var uuid = translate.util.uuid();\n    //console.log('=====')\n    //console.log(translate.nodeQueue);\n\n    /* v2.4.3 将初始化放到了 translate.element.whileNodes 中，如果uuid对应的没有，则自动创建\n     translate.nodeQueue[uuid] = new Array(); //创建\n    translate.nodeQueue[uuid]['expireTime'] = Date.now() + 120*1000; //删除时间，10分钟后删除\n    translate.nodeQueue[uuid]['list'] = new Array(); \n    */\n    //console.log(translate.nodeQueue);\n    //console.log('=====end')\n\n    //如果页面打开第一次使用，先判断缓存中有没有上次使用的语种，从缓存中取出\n    if (translate.to == null || translate.to == '') {\n      var to_storage = translate.storage.get('to');\n      if (to_storage != null && typeof to_storage != 'undefined' && to_storage.length > 0) {\n        translate.to = to_storage;\n      }\n    }\n\n    //渲染select选择语言\n    try {\n      translate.selectLanguageTag.render();\n    } catch (e) {\n      console.log(e);\n    }\n\n    //判断是否还未指定翻译的目标语言\n    if (translate.to == null || typeof translate.to == 'undefined' || translate.to.length == 0) {\n      //未指定，判断如果指定了自动获取用户本国语种了，那么进行获取\n      if (translate.autoDiscriminateLocalLanguage) {\n        translate.executeByLocalLanguage();\n      }\n\n      //没有指定翻译目标语言、又没自动获取用户本国语种，则不翻译\n      return;\n    }\n\n    //判断本地语种跟要翻译的目标语种是否一样，如果是一样，那就不需要进行任何翻译\n    if (translate.to == translate.language.getLocal()) {\n      return;\n    }\n\n    /********** 翻译进行 */\n\n    //先进行图片的翻译替换，毕竟图片还有加载的过程\n    translate.images.execute();\n\n    /*\n      进行翻译指定的node操作。优先级为：\n      1. 这个方法已经指定的翻译 nodes\n      2. setDocuments 指定的 \n      3. 整个网页 \n      其实2、3都是通过 getDocuments() 取，在getDocuments() 就对2、3进行了判断\n    */\n    var all;\n    if (typeof docs != 'undefined') {\n      //1. 这个方法已经指定的翻译 nodes\n\n      if (docs == null) {\n        //要翻译的目标区域不存在\n        console.log('translate.execute(...) 中传入的要翻译的目标区域不存在。');\n        return;\n      }\n      if (typeof docs.length == 'undefined') {\n        //不是数组，是单个元素\n        all = new Array();\n        all[0] = docs;\n      } else {\n        //是数组，直接赋予\n        all = docs;\n      }\n    } else {\n      //2、3\n      all = translate.getDocuments();\n    }\n    //console.log('----要翻译的目标元素-----');\n    //console.log(all)\n\n    //检索目标内的node元素\n    for (var i = 0; i < all.length & i < 20; i++) {\n      var node = all[i];\n      translate.element.whileNodes(uuid, node);\n    }\n\n    //console.log('-----待翻译：----');\n    //console.log(translate.nodeQueue);\n\n    //translateTextArray[lang][0]\n    var translateTextArray = {}; //要翻译的文本的数组，格式如 [\"你好\",\"欢迎\"]\n    var translateHashArray = {}; //要翻译的文本的hash,跟上面的index是一致的，只不过上面是存要翻译的文本，这个存hash值\n\n    for (var lang in translate.nodeQueue[uuid]['list']) {\n      //二维数组中，取语言\n      //console.log('lang:'+lang); //lang为english这种语言标识\n      if (lang == null || typeof lang == 'undefined' || lang.length == 0 || lang == 'undefined') {\n        //console.log('lang is null : '+lang);\n        continue;\n      }\n      translateTextArray[lang] = [];\n      translateHashArray[lang] = [];\n      let task = new translate.renderTask();\n      //console.log(translate.nodeQueue);\n      //二维数组，取hash、value\n      for (var hash in translate.nodeQueue[uuid]['list'][lang]) {\n        if (typeof translate.nodeQueue[uuid]['list'][lang][hash] == 'function') {\n          //跳出，增加容错率。  正常情况下应该不会这样\n          continue;\n        }\n\n        //取原始的词，还未经过翻译的，需要进行翻译的词\n        //var originalWord = translate.nodeQueue[uuid]['list'][lang][hash]['original'];\t\n\n        //原始的node中的词\n        var originalWord = translate.nodeQueue[uuid]['list'][lang][hash]['original'];\n        //要翻译的词\n        var translateText = translate.nodeQueue[uuid]['list'][lang][hash]['translateText'];\n\n        /*\n                //自定义术语后的。如果\n                var nomenclatureOriginalWord = translate.nomenclature.dispose(cache);\n                if(nomenclatureOriginalWord != originalWord){\n                  has\n                }\n        */\n        //console.log(originalWord == translateText ? '1':'xin：'+translateText);\n        //根据hash，判断本地是否有缓存了\n        var cacheHash = originalWord == translateText ? hash : translate.util.hash(translateText); //如果匹配到了自定义术语库，那翻译前的hash是被改变了\n        translate.nodeQueue[uuid]['list'][lang][hash]['cacheHash'] = cacheHash; //缓存的hash。 缓存时，其hash跟翻译的语言是完全对应的，缓存的hash就是翻译的语言转换来的\n        var cache = translate.storage.get('hash_' + translate.to + '_' + cacheHash);\n        //console.log(key+', '+cache);\n        if (cache != null && cache.length > 0) {\n          //有缓存了\n          //console.log('find cache：'+cache);\n          //console.log(this.nodeQueue[lang][hash]['nodes']);\n          //直接将缓存赋予\n          //for(var index = 0; index < this.nodeQueue[lang][hash].length; index++){\n          //this.nodeQueue[lang][hash][index].nodeValue = cache;\n\n          for (var node_index = 0; node_index < translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length; node_index++) {\n            //this.nodeQueue[lang][hash]['nodes'][node_index].nodeValue = cache;\n            //console.log(originalWord);\n            task.add(translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['node'], originalWord, translate.nodeQueue[uuid]['list'][lang][hash]['beforeText'] + cache + translate.nodeQueue[uuid]['list'][lang][hash]['afterText'], translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['attribute']);\n            //this.nodeQueue[lang][hash]['nodes'][node_index].nodeValue = this.nodeQueue[lang][hash]['nodes'][node_index].nodeValue.replace(new RegExp(originalWord,'g'), cache);\n          }\n          //}\n\n          continue; //跳出，不用在传入下面的翻译接口了\n        }\n\n        /*\n        //取出数组\n        var queueNodes = this.nodeQueue[lang][hash];\n        if(queueNodes.length > 0){\n          //因为在这个数组中的值都是一样的，那么只需要取出第一个就行了\n          var valueStr = queueNodes[0].nodeValue;\n          valueStr = this.util.charReplace(valueStr);\n           translateTextArray[lang].push(valueStr);\n          translateHashArray[lang].push(hash);\n        }\n        */\n\n        //加入待翻译数组\n        translateTextArray[lang].push(translateText);\n        translateHashArray[lang].push(hash); //这里存入的依旧还是用原始hash，未使用自定义术语库前的hash，目的是不破坏 nodeQueue 的 key\n      }\n      task.execute(); //执行渲染任务\n    }\n\n    //window.translateHashArray = translateHashArray;\n\n    //统计出要翻译哪些语种 ，这里面的语种会调用接口进行翻译。其内格式如 english\n    var fanyiLangs = [];\n    for (var lang in translate.nodeQueue[uuid]['list']) {\n      //二维数组中取语言\n      if (translateTextArray[lang].length < 1) {\n        continue;\n      }\n      fanyiLangs.push(lang);\n    }\n\n    /******* 用以记录当前是否进行完第一次翻译了 *******/\n    if (!translate.listener.isExecuteFinish) {\n      translate.temp_executeFinishNumber = 0; //下面请求接口渲染，翻译执行完成的次数\t\n      //判断是否是执行完一次了\n      translate.temp_executeFinishInterval = setInterval(function () {\n        if (translate.temp_executeFinishNumber == fanyiLangs.length) {\n          translate.listener.isExecuteFinish = true; //记录当前已执行完第一次了\n          clearInterval(translate.temp_executeFinishInterval); //停止\n          //console.log('translate.execute() Finish!');\n        }\n      }, 50);\n    }\n    if (fanyiLangs.length == 0) {\n      //没有需要翻译的，直接退出\n      return;\n    }\n\n    //进行掉接口翻译\n    for (var lang_index in fanyiLangs) {\n      //一维数组，取语言\n      var lang = fanyiLangs[lang_index];\n      //console.log(typeof(translateTextArray[lang]))\n\n      if (typeof translateTextArray[lang] == 'undefined' || translateTextArray[lang].length < 1) {\n        return;\n      }\n\n      //自定义术语\n      /*var nomenclatureCache = translate.nomenclature.dispose(cache);\n      for(var ttr_index = 0; ttr_index<translateTextArray[lang].length; ttr_index++){\n        console.log(translateTextArray[lang][ttr_index])\n      }*/\n\n      /*** 翻译开始 ***/\n      var url = translate.request.api.host + translate.request.api.translate + '?v=' + translate.version;\n      var data = {\n        from: lang,\n        to: translate.to,\n        //text:JSON.stringify(translateTextArray[lang])\n        text: encodeURIComponent(JSON.stringify(translateTextArray[lang]))\n      };\n      translate.request.post(url, data, function (data) {\n        //console.log(data); \n        if (data.result == 0) {\n          console.log('=======ERROR START=======');\n          console.log(translateTextArray[data.from]);\n          //console.log(encodeURIComponent(JSON.stringify(translateTextArray[data.from])));\n\n          console.log('response : ' + data.info);\n          console.log('=======ERROR END  =======');\n          translate.temp_executeFinishNumber++; //记录执行完的次数\n          return;\n        }\n\n        //console.log('-----待翻译3：----');\n        //console.log(translate.nodeQueue);\n\n        //console.log('response:'+uuid);\n        let task = new translate.renderTask();\n        //遍历 translateHashArray\n        for (var i = 0; i < translateHashArray[data.from].length; i++) {\n          //翻译前的语种，如 english\n          var lang = data.from;\n          //翻译后的内容\n          var text = data.text[i];\n          //翻译前的hash对应下标\n          var hash = translateHashArray[data.from][i];\n          var cacheHash = translate.nodeQueue[uuid]['list'][lang][hash]['cacheHash'];\n\n          //取原始的词，还未经过翻译的，需要进行翻译的词\n          var originalWord = '';\n          try {\n            originalWord = translate.nodeQueue[uuid]['list'][lang][hash]['original'];\n            //console.log('bef:'+translate.nodeQueue[uuid]['list'][lang][hash]['beforeText']);\n          } catch (e) {\n            console.log('uuid:' + uuid + ', originalWord:' + originalWord + ', lang:' + lang + ', hash:' + hash + ', text:' + text + ', queue:' + translate.nodeQueue[uuid]);\n            console.log(e);\n            continue;\n          }\n\n          //for(var index = 0; index < translate.nodeQueue[lang][hash].length; index++){\n          for (var node_index = 0; node_index < translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length; node_index++) {\n            //translate.nodeQueue[lang][hash]['nodes'][node_index].nodeValue = translate.nodeQueue[lang][hash]['nodes'][node_index].nodeValue.replace(new RegExp(originalWord,'g'), text);\n            //加入任务\n            task.add(translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['node'], originalWord, translate.nodeQueue[uuid]['list'][lang][hash]['beforeText'] + text + translate.nodeQueue[uuid]['list'][lang][hash]['afterText'], translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['attribute']);\n          }\n          //}\n          /*\n          for(var index = 0; index < translate.nodeQueue[data.from][hash].length; index++){\n            translate.nodeQueue[data.from][hash][index].nodeValue = text;\n          }\n          */\n\n          //将翻译结果以 key：hash  value翻译结果的形式缓存\n          translate.storage.set('hash_' + data.to + '_' + cacheHash, text);\n        }\n        task.execute(); //执行渲染任务\n        translate.temp_executeFinishNumber++; //记录执行完的次数\n      });\n      /*** 翻译end ***/\n    }\n  },\n  element: {\n    //对翻译前后的node元素的分析（翻以前）及渲染（翻译后）\n    nodeAnalyse: {\n      /*\n        获取node中的要进行翻译的文本内容、以及要操作的实际node对象（这个node对象很可能是传入的node中的某个子node）\n        node \n        attribute 要获取的是某个属性的值，还是node本身的值。比如 a标签的title属性的值，则传入 title。  如果是直接获取node.nodeValue ，那这个没有\n         返回结果是一个数组。其中：\n          ['text']:要进行翻译的text内容文本\n          ['node']:要进行翻译的目标node\n       */\n      get: function (node, attribute) {\n        return translate.element.nodeAnalyse.analyse(node, '', '', attribute);\n      },\n      /*\n        进行翻译之后的渲染显示\n        参数：\n          node 当前翻译的node元素\n          originalText 翻译之前的内容文本\n          resultText 翻译之后的内容文本\n          attribute 存放要替换的属性，比如 a标签的title属性。 如果是直接替换node.nodeValue ，那这个没有\n      */\n      set: function (node, originalText, resultText, attribute) {\n        translate.element.nodeAnalyse.analyse(node, originalText, resultText, attribute);\n      },\n      /*\t\n      \t\n        注意，这个不使用，只是服务于上面的get、set使用。具体使用用上面的get、set\n         1. 只传入 node：\n          获取node中的要进行翻译的文本内容、以及要操作的实际node对象（这个node对象很可能是传入的node中的某个子node）\n          返回结果是一个数组。其中：\n            ['text']:要进行翻译的text内容文本\n            ['node']:要进行翻译的目标node\n        2. 传入 node、originalText、 resultText\n          则是进行翻译之后的渲染显示\n         attribute : 进行替换渲染时使用，存放要替换的属性，比如 a标签的title属性。 如果是直接替换node.nodeValue ，那这个没有\n      */\n      analyse: function (node, originalText, resultText, attribute) {\n        var result = new Array(); //返回的结果\n        result['node'] = node;\n        result['text'] = '';\n        var nodename = translate.element.getNodeName(node);\n        if (attribute != null && typeof attribute == 'string' && attribute.length > 0) {\n          //这个node有属性，替换的是node的属性，而不是nodeValue\n          result['text'] = node[attribute];\n\n          //替换渲染\n          if (typeof originalText != 'undefined' && originalText.length > 0) {\n            if (typeof node[attribute] != 'undefined') {\n              node[attribute] = node[attribute].replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n            } else {\n              console.log(node);\n            }\n          }\n          return result;\n        }\n\n        //正常的node ，typeof 都是 object\n\n        //console.log(typeof(node)+node);\n        if (nodename == '#text') {\n          //如果是普通文本，判断一下上层是否是包含在textarea标签中\n          if (typeof node.parentNode != 'undefined') {\n            var parentNodename = translate.element.getNodeName(node.parentNode);\n            //console.log(parentNodename)\n            if (parentNodename == 'TEXTAREA') {\n              //是textarea标签，那将nodename 纳入 textarea的判断中，同时将判断对象交于上级，也就是textarea标签\n              nodename = 'TEXTAREA';\n              node = node.parentNode;\n            }\n          }\n        }\n\n        //console.log(nodename)\n        //console.log(translate.element.getNodeName(node.parentNode))\n        //console.log(node)\n        if (nodename == 'INPUT' || nodename == 'TEXTAREA') {\n          //console.log(node.attributes)\n          /*\n            1. input、textarea 输入框，要对 placeholder 做翻译\n            2. input 要对 type=button 的情况进行翻译\n          */\n          if (node.attributes == null || typeof node.attributes == 'undefined') {\n            result['text'] = '';\n            return result;\n          }\n\n          //input，要对 type=button、submit 的情况进行翻译\n          if (nodename == 'INPUT') {\n            if (typeof node.attributes.type != 'undefined' && typeof node.attributes.type.nodeValue != null && (node.attributes.type.nodeValue.toLowerCase() == 'button' || node.attributes.type.nodeValue.toLowerCase() == 'submit')) {\n              //console.log('----是 <input type=\"button\"');\n              //取它的value\n              var input_value_node = node.attributes.value;\n              if (input_value_node != null && typeof input_value_node != 'undefined' && typeof input_value_node.nodeValue != 'undefined' && input_value_node.nodeValue.length > 0) {\n                //替换渲染\n                if (typeof originalText != 'undefined' && originalText.length > 0) {\n                  //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n                  input_value_node.nodeValue = input_value_node.nodeValue.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n                }\n                result['text'] = input_value_node.nodeValue;\n                result['node'] = input_value_node;\n                return result;\n              }\n            }\n          }\n          //console.log(node)\n\n          //input textarea 的 placeholder 情况\n          if (typeof node.attributes['placeholder'] != 'undefined') {\n            //console.log(node);\n            //替换渲染\n            if (typeof originalText != 'undefined' && originalText.length > 0) {\n              //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n              node.attributes['placeholder'].nodeValue = node.attributes['placeholder'].nodeValue.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n            }\n            result['text'] = node.attributes['placeholder'].nodeValue;\n            result['node'] = node.attributes['placeholder'];\n            return result;\n            //return node.attributes['placeholder'].nodeValue;\n          }\n          //console.log(node)\n          result['text'] = '';\n          return result;\n        }\n        if (nodename == 'META') {\n          //meta标签，如是关键词、描述等\n          if (typeof node.name != 'undefined' && node.name != null) {\n            var nodeAttributeName = node.name.toLowerCase(); //取meta 标签的name 属性\n            if (nodeAttributeName == 'keywords' || nodeAttributeName == 'description') {\n              //替换渲染\n              if (typeof originalText != 'undefined' && originalText.length > 0) {\n                //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n                node.content = node.content.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n              }\n              result['text'] = node.content;\n              return result;\n            }\n          }\n          result['text'] = '';\n          return result;\n        }\n        if (nodename == 'IMG') {\n          if (typeof node.alt == 'undefined' || node.alt == null) {\n            result['text'] = '';\n            return result;\n          }\n\n          //替换渲染\n          if (typeof originalText != 'undefined' && originalText.length > 0) {\n            //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            node.alt = node.alt.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n          }\n          result['text'] = node.alt;\n          return result;\n        }\n\n        //其他的\n        if (node.nodeValue == null || typeof node.nodeValue == 'undefined') {\n          result['text'] = '';\n        } else if (node.nodeValue.trim().length == 0) {\n          //避免就是单纯的空格或者换行\n          result['text'] = '';\n        } else {\n          //替换渲染\n          if (typeof originalText != 'undefined' && originalText.length > 0) {\n            //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            node.nodeValue = node.nodeValue.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n          }\n          result['text'] = node.nodeValue;\n        }\n        return result;\n      }\n    },\n    //获取这个node元素的node name ,如果未发现，则返回''空字符串\n    getNodeName: function (node) {\n      if (node == null || typeof node == 'undefined') {\n        return '';\n      }\n      if (node.nodeName == null || typeof node.nodeName == 'undefined') {\n        return '';\n      }\n      var nodename = node.nodeName;\n      //console.log('nodename:'+nodename+', node:'+node);\n      return nodename;\n    },\n    //向下遍历node\n    whileNodes: function (uuid, node) {\n      if (node == null || typeof node == 'undefined') {\n        return;\n      }\n\n      //如果这个uuid没有，则创建\n      if (typeof translate.nodeQueue[uuid] == 'undefined' || translate.nodeQueue[uuid] == null) {\n        translate.nodeQueue[uuid] = new Array(); //创建\n        translate.nodeQueue[uuid]['expireTime'] = Date.now() + 120 * 1000; //删除时间，10分钟后删除\n        translate.nodeQueue[uuid]['list'] = new Array();\n        //console.log('创建 --- ');\n        //console.log(uuid)\n      }\n\n      //console.log('---'+typeof(node)+', ');\n      //判断是否是有title属性，title属性也要翻译\n      if (typeof node == 'object' && typeof node['title'] == 'string' && node['title'].length > 0) {\n        //将title加入翻译队列\n        //console.log('---'+node.title+'\\t'+node.tagName);\n        //console.log(node)\n        //console.log('------------');\n\n        //判断当前元素是否在ignore忽略的tag、id、class name中\n        if (!translate.ignore.isIgnore(node)) {\n          //不在忽略的里面，才会加入翻译\n          translate.addNodeToQueue(uuid, node, node['title'], 'title');\n        }\n      }\n      var childNodes = node.childNodes;\n      if (childNodes.length > 0) {\n        for (var i = 0; i < childNodes.length; i++) {\n          translate.element.whileNodes(uuid, childNodes[i]);\n        }\n      } else {\n        //单个了\n        translate.element.findNode(uuid, node);\n      }\n    },\n    findNode: function (uuid, node) {\n      if (node == null || typeof node == 'undefined') {\n        return;\n      }\n      //console.log(node)\n      if (node.parentNode == null) {\n        return;\n      }\n      //console.log('-----parent')\n      var parentNodeName = translate.element.getNodeName(node.parentNode);\n      //node.parentNode.nodeName;\n      if (parentNodeName == '') {\n        return;\n      }\n      if (translate.ignore.tag.indexOf(parentNodeName.toLowerCase()) > -1) {\n        //忽略tag\n        //console.log('忽略tag：'+parentNodeName);\n        return;\n      }\n\n      /****** 判断忽略的class ******/\n      /*\n      这段理论上不需要了，因为在  translate.ignore.isIgnore 判断了\n      var ignoreClass = false;\t//是否是被忽略的class，true是\n      var parentNode = node.parentNode;\n      while(node != parentNode && parentNode != null){\n        //console.log('node:'+node+', parentNode:'+parentNode);\n        if(parentNode.className != null){\n          if(translate.ignore.class.indexOf(parentNode.className) > -1){\n            //发现ignore.class 当前是处于被忽略的 class\n            ignoreClass = true;\n          }\n        }\n      \t\n        parentNode = parentNode.parentNode;\n      }\n      if(ignoreClass){\n        //console.log('ignore class :  node:'+node.nodeValue);\n        return;\n      }\n      */\n      /**** 判断忽略的class结束 ******/\n\n      /**** 避免中途局部翻译，在判断一下 ****/\n      //判断当前元素是否在ignore忽略的tag、id、class name中\n      if (translate.ignore.isIgnore(node)) {\n        //console.log('node包含在要忽略的元素中：');\n        //console.log(node);\n        return;\n      }\n\n      //node分析\n      var nodeAnaly = translate.element.nodeAnalyse.get(node);\n      if (nodeAnaly['text'].length > 0) {\n        //有要翻译的目标内容，加入翻译队列\n        //console.log('addNodeToQueue -- '+nodeAnaly['node']+', text:' + nodeAnaly['text']);\n        translate.addNodeToQueue(uuid, nodeAnaly['node'], nodeAnaly['text']);\n      }\n\n      /*\n      //console.log(node.nodeName+', type:'+node.nodeType+', '+node.nodeValue);\n      var nodename = translate.element.getNodeName(node);\n      if(nodename == 'INPUT' || nodename == 'TEXTAREA'){\n        //input 输入框，要对 placeholder 做翻译\n        console.log('input---'+node.attributes);\n        if(node.attributes == null || typeof(node.attributes) == 'undefined'){\n          return;\n        }\n          if(typeof(node.attributes['placeholder']) != 'undefined'){\n          //console.log(node.attributes['placeholder'].nodeValue);\n          //加入要翻译的node队列\n          //translate.nodeQueue[translate.hash(node.nodeValue)] = node.attributes['placeholder'];\n          //加入要翻译的node队列\n          //translate.addNodeToQueue(translate.hash(node.attributes['placeholder'].nodeValue), node.attributes['placeholder']);\n          translate.addNodeToQueue(uuid, node.attributes['placeholder'], node.attributes['placeholder'].nodeValue);\n        }\n      \t\n        //console.log(node.getAttribute(\"placeholder\"));\n      }else if(nodename == 'META'){\n        //meta标签，如是关键词、描述等\n        if(typeof(node.name) != 'undefined' && node.name != null){\n          var nodeAttributeName = node.name.toLowerCase();  //取meta 标签的name 属性\n          //console.log(nodeName);\n          if(nodeAttributeName == 'keywords' || nodeAttributeName == 'description'){\n            //关键词、描述\n            translate.addNodeToQueue(uuid, node, node.content);\n          }\n        }\n        //console.log(node.name)\n      }else if(nodename == 'IMG'){\n        //console.log('-------'+node.alt);\n        translate.addNodeToQueue(uuid, node, node.alt);\n      }else if(node.nodeValue != null && node.nodeValue.trim().length > 0){\n          //过滤掉无效的值\n        if(node.nodeValue != null && typeof(node.nodeValue) == 'string' && node.nodeValue.length > 0){\n        }else{\n          return;\n        }\n          //console.log(node.nodeValue+' --- ' + translate.language.get(node.nodeValue));\n      \t\n        //console.log(node.nodeName);\n        //console.log(node.parentNode.nodeName);\n        //console.log(node.nodeValue);\n        //加入要翻译的node队列\n        translate.addNodeToQueue(uuid, node, node.nodeValue);\t\n        //translate.addNodeToQueue(translate.hash(node.nodeValue), node);\n        //translate.nodeQueue[translate.hash(node.nodeValue)] = node;\n        //translate.nodeQueue[translate.hash(node.nodeValue)] = node.nodeValue;\n        //node.nodeValue = node.nodeValue+'|';\n        }\n      */\n    }\n  },\n  /*\n   * 将发现的元素节点加入待翻译队列\n   * uuid execute方法执行的唯一id\n   * node 当前text所在的node\n   * text 当前要翻译的目标文本\n   * attribute 是否是元素的某个属性。比如 a标签中的title属性， a.title 再以node参数传入时是string类型的，本身并不是node类型，所以就要传入这个 attribute=title 来代表这是a标签的title属性。同样第二个参数node传入的也不能是a.title，而是传入a这个node元素\n   */\n  addNodeToQueue: function (uuid, node, text, attribute) {\n    if (node == null || text == null || text.length == 0) {\n      return;\n    }\n    //console.log('find tag ignore : '+node.nodeValue+', '+node.nodeName+\", \"+node.nodeType+\", \"+node.tagName);\n    //console.log('addNodeToQueue into -- node:'+node+', text:'+text+', attribute:'+attribute);\n    var nodename = translate.element.getNodeName(node);\n\n    //判断如果是被 <!--  --> 注释的区域，不进行翻译\n    if (nodename.toLowerCase() == '#comment') {\n      return;\n    }\n    //console.log('\\t\\t'+text);\n    //取要翻译字符的hash\n    var key = translate.util.hash(text);\n    /*\n    如果是input 的 placeholder ,就会出现这个情况\n    if(node.parentNode == null){\n      console.log('node.parentNode == null');\n      return;\n    }\n    */\n\n    //console.log(node.parentNode);\n    //console.log(node.parentNode.nodeName);\n\n    if (translate.util.findTag(text)) {\n      //console.log('find tag ignore : '+node.nodeValue+', '+node.nodeName+\", \"+node.nodeType+\", \"+node.tagName);\n      //console.log(node.parentNode.nodeName);\n\n      //获取到当前文本是属于那个tag标签中的，如果是script、style 这样的标签中，那也会忽略掉它，不进行翻译\n      if (node.parentNode == null) {\n        //没有上级了，或是没获取到上级，忽略\n        return;\n      }\n      //去上级的tag name\n      var parentNodeName = translate.element.getNodeName(node.parentNode);\n      //node.parentNode.nodeName;\n      if (parentNodeName == 'SCRIPT' || parentNodeName == 'STYLE') {\n        //如果是script、style中发现的，那也忽略\n        return;\n      }\n    }\n    //console.log(node.nodeValue);\n\n    //获取当前是什么语种\n    var langs = translate.language.get(text);\n    //console.log('langs');\n    //console.log(langs);\n\n    //过滤掉要转换为的目标语种，比如要转为英语，那就将本来是英语的部分过滤掉，不用再翻译了\n    if (typeof langs[translate.to] != 'undefined') {\n      delete langs[translate.to];\n    }\n\n    /* if(this.nodeQueue[lang] == null || typeof(this.nodeQueue[lang]) == 'undefined'){\n      this.nodeQueue[lang] = new Array();\n    } \n    //创建二维数组\n    if(this.nodeQueue[lang][key] == null || typeof(this.nodeQueue[lang][key]) == 'undefined'){\n      this.nodeQueue[lang][key] = new Array();\n    }\n    */\n    //console.log(langs);\n\n    for (var lang in langs) {\n      //创建二维数组， key为语种，如 english\n      if (translate.nodeQueue[uuid]['list'][lang] == null || typeof translate.nodeQueue[uuid]['list'][lang] == 'undefined') {\n        translate.nodeQueue[uuid]['list'][lang] = new Array();\n      }\n      //console.log('|'+langs[lang].length);\n      //遍历出该语种下有哪些词需要翻译\n      for (var word_index = 0; word_index < langs[lang].length; word_index++) {\n        //console.log('start:'+word_index)\n        //console.log(langs[lang][word_index]);\n        if (typeof langs[lang][word_index] == 'undefined' || typeof langs[lang][word_index]['text'] == 'undefined') {\n          //理论上应该不会，但多加个判断\n          continue;\n        }\n        var word = langs[lang][word_index]['text']; //要翻译的词\n        var beforeText = langs[lang][word_index]['beforeText'];\n        var afterText = langs[lang][word_index]['afterText'];\n\n        //console.log(\"word:\"+word+', bef:'+beforeText+', after:'+afterText)\n        var hash = translate.util.hash(word); //要翻译的词的hash\n        //console.log(hash);\n\n        //创建三维数组， key为要通过接口翻译的文本词或句子的 hash （注意并不是node的文本，而是node拆分后的文本）\n        if (translate.nodeQueue[uuid]['list'][lang][hash] == null || typeof translate.nodeQueue[uuid]['list'][lang][hash] == 'undefined') {\n          translate.nodeQueue[uuid]['list'][lang][hash] = new Array();\n\n          /*\n           * 创建四维数组，存放具体数据\n           * key: nodes 包含了这个hash的node元素的数组集合，array 多个。其中\n                nodes[index]['node'] 存放当前的node元素\n                nodes[index]['attribute'] 存放当前hash，也就是翻译文本针对的是什么，是node本身（nodeValue），还是 node 的某个属性，比如title属性。如果这里不为空，那就是针对的属性操作的\n           * key: original 原始的要翻译的词或句子，html加载完成但还没翻译前的文本，用于支持当前页面多次语种翻译切换而无需跳转\n           * beforeText、afterText:见 translate.nodeQueue 的说明\n           */\n          translate.nodeQueue[uuid]['list'][lang][hash]['nodes'] = new Array();\n          translate.nodeQueue[uuid]['list'][lang][hash]['original'] = word;\n          translate.nodeQueue[uuid]['list'][lang][hash]['translateText'] = translate.nomenclature.dispose(word); //自定义术语处理\n          translate.nodeQueue[uuid]['list'][lang][hash]['beforeText'] = beforeText;\n          translate.nodeQueue[uuid]['list'][lang][hash]['afterText'] = afterText;\n          //translate.nodeQueue[uuid]['list'][lang][hash]['attribute'] = attribute; //放入 nodes[index][attribute] 元素中\n\n          //其中key： nodes 是第四维数组，里面存放具体的node元素对象\n\n          //console.log(translate.nodeQueue[uuid]['list'][lang][hash]);\n        }\n        if (typeof node.isSameNode != 'undefined') {\n          //支持 isSameNode 方法判断对象是否相等\n          for (var node_index = 0; node_index < translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length; node_index++) {\n            if (node.isSameNode(translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['node'])) {\n              //相同，那就不用在存入了\n              //console.log('相同，那就不用在存入了')\n              //console.log(node)\n              continue;\n            }\n          }\n        }\n\n        //往五维数组nodes中追加node元素\n        var nodesIndex = translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length;\n        translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][nodesIndex] = new Array();\n        translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][nodesIndex]['node'] = node;\n        translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][nodesIndex]['attribute'] = attribute;\n        //console.log('end:'+word_index)\n      }\n    }\n\n    //this.nodeQueue[lang][key][this.nodeQueue[lang][key].length]=node; //往数组中追加\n  },\n  language: {\n    //当前本地语种，本地语言，默认是简体中文。设置请使用 translate.language.setLocal(...)。不可直接使用，使用需用 getLocal()\n    local: '',\n    //传入语种。具体可传入哪些参考： http://api.translate.zvo.cn/doc/language.json.html\n    setLocal: function (languageName) {\n      translate.setUseVersion2(); //Set to use v2.x version\n      translate.language.local = languageName;\n    },\n    //获取当前本地语种，本地语言，默认是简体中文。设置请使用 translate.language.setLocal(...)\n    getLocal: function () {\n      //判断是否设置了本地语种，如果没设置，自动给其设置\n      if (translate.language.local == null || translate.language.local.length < 1) {\n        translate.language.autoRecognitionLocalLanguage();\n      }\n      return translate.language.local;\n    },\n    /*\n      获取当前语种。\n      比如当前设置的本地语种是简体中文，用户并未切换其他语种，那么这个方法将返回本地当前的语种，也就是等同于 translate.language.getLocal()\n      如果用户切换为英语进行浏览，那么这个方法将返回翻译的目标语种，也就是 english\n    */\n    getCurrent: function () {\n      var to_storage = translate.storage.get('to');\n      if (to_storage != null && typeof to_storage != 'undefined' && to_storage.length > 0) {\n        //之前有过使用，并且主动设置过目标语种\n        return to_storage;\n      }\n      return translate.language.getLocal();\n    },\n    //如果第一次用，默认以什么语种显示。\n    //比如本地当前语种是简体中文，这里设置为english，那么用户第一次使用时，会自动翻译为english进行显示。如果用户手动切换为其他语种比如韩语，那么就遵循用户手动切换的为主，显示韩语。\n    setDefaultTo: function (languageName) {\n      var to_storage = translate.storage.get('to');\n      if (to_storage != null && typeof to_storage != 'undefined' && to_storage.length > 0) {\n        //之前有过使用，并且主动设置过目标语种，那么不进行处理\n      } else {\n        //没有设置过，进行处理\n        translate.storage.set('to', languageName);\n        translate.to = languageName;\n      }\n    },\n    //根据URL传参控制以何种语种显示\n    //设置可以根据当前访问url的某个get参数来控制使用哪种语言显示。\n    //比如当前语种是简体中文，网页url是http://translate.zvo.cn/index.html ,那么可以通过在url后面增加 language 参数指定翻译语种，来使网页内容以英文形态显示 http://translate.zvo.cn/index.html?language=english\n    setUrlParamControl: function (paramName) {\n      if (typeof paramName == 'undefined' || paramName.length < 1) {\n        paramName = 'language';\n      }\n      var paramValue = translate.util.getUrlParam(paramName);\n      if (typeof paramValue == 'undefined') {\n        return;\n      }\n      if (paramValue == '' || paramValue == 'null' || paramValue == 'undefined') {\n        return;\n      }\n      translate.storage.set('to', paramValue);\n      translate.to = paramValue;\n    },\n    //自动识别当前页面是什么语种\n    autoRecognitionLocalLanguage: function () {\n      if (translate.language.local != null && translate.language.local.length > 2) {\n        //已设置过了，不需要再设置\n        return;\n      }\n      var bodyText = document.body.outerText;\n      if (bodyText == null || typeof bodyText == 'undefined' || bodyText.length < 1) {\n        //未取到，默认赋予简体中文\n        translate.language.local = 'chinese_simplified';\n        return;\n      }\n      bodyText = bodyText.replace(/\\n|\\t|\\r/g, ''); //将回车换行等去掉\n\n      var langs = new Array(); //上一个字符的语种是什么，当前字符向上数第一个字符。格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。 \n      for (var i = 0; i < bodyText.length; i++) {\n        var charstr = bodyText.charAt(i);\n        var lang = translate.language.getCharLanguage(charstr);\n        if (lang == '') {\n          //未获取到，未发现是什么语言\n          //continue;\n          lang = 'unidentification';\n        }\n        langs.push(lang);\n      }\n\n      //从数组中取出现频率最高的\n      var newLangs = translate.util.arrayFindMaxNumber(langs);\n\n      //移除数组中的特殊字符\n      var index = newLangs.indexOf('specialCharacter');\n      if (index > -1) {\n        newLangs.splice(index, 1); //移除数组中的特殊字符\n      }\n      if (newLangs.length > 0) {\n        //找到排序出现频率最多的\n        translate.language.local = newLangs[0];\n      } else {\n        //没有，默认赋予简体中文\n        translate.language.local = 'chinese_simplified';\n      }\n    },\n    /*\n     * 获取当前字符是什么语种。返回值是一个语言标识，有  chinese_simplified简体中文、japanese日语、korean韩语、\n     * str : node.nodeValue 或 图片的 node.alt 等\n     * 如果语句长，会全句翻译，以保证翻译的准确性，提高可读性。\n     * 如果语句短，会自动将特殊字符、要翻译的目标语种给过滤掉，只取出具体的要翻译的目标语种文本\n     */\n    get: function (str) {\n      //将str拆分为单个char进行判断\n\n      var langs = new Array(); //当前字符串包含哪些语言的数组，其内如 english\n      var langStrs = new Array(); //存放不同语言的文本，格式如 ['english'][0] = 'hello'\n      var upLangs = []; //上一个字符的语种是什么，当前字符向上数第一个字符。格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。 \n      var upLangsTwo = []; //上二个字符的语种是什么 ，当前字符向上数第二个字符。 格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。\n\n      //var upLangs = ''; //上一个字符的语种是什么，格式如 english\n      for (var i = 0; i < str.length; i++) {\n        var charstr = str.charAt(i);\n        //console.log('charstr:'+charstr)\n        var lang = translate.language.getCharLanguage(charstr);\n        if (lang == '') {\n          //未获取到，未发现是什么语言\n          //continue;\n          lang = 'unidentification';\n        }\n        var result = translate.language.analyse(lang, langStrs, upLangs, upLangsTwo, charstr);\n        //console.log(result)\n        langStrs = result['langStrs'];\n        //记录上几个字符\n        if (typeof upLangs['language'] != 'undefined') {\n          upLangsTwo['language'] = upLangs['language'];\n          upLangsTwo['charstr'] = upLangs['charstr'];\n          upLangsTwo['storage_language'] = upLangs['storage_language'];\n        }\n        //upLangs['language'] = lang;\n        upLangs['language'] = result['storage_language'];\n        upLangs['charstr'] = charstr;\n        upLangs['storage_language'] = result['storage_language'];\n        //console.log(result['storage_language'])\n        //console.log(upLangs['language']);\n        langs.push(lang);\n      }\n\n      //console.log(langStrs);\n\n      //console.log(langs);\n      //console.log(langStrs);\n\n      /*\n            //从数组中取出现频率最高的\n            var newLangs = translate.util.arrayFindMaxNumber(langs);\n          \t\n            //移除当前翻译目标的语言。因为已经是目标预言了，不需要翻译了\n            var index = newLangs.indexOf(translate.to);\n            if(index > -1){\n              newLangs.splice(index,1); //移除\n            }\n      \n            //移除特殊字符\n            var index = newLangs.indexOf('specialCharacter');\n            if(index > -1){\n              newLangs.splice(index,1); //移除数组中的特殊字符\n            }\n      \n            if(newLangs.length > 0){\n              //还剩一个或多个，（如果是多个，那应该是这几个出现的频率一样，所以取频率最高的时返回了多个）\n              return newLangs[0];\n            }else{\n              //没找到，直接返回空字符串\n              return '';\n            }\n            */\n\n      //去除特殊符号\n      //for(var i = 0; i<langStrs.length; i++){\n      /*\n      var i = 0;\n      for(var item in langStrs) {\n        if(item == 'unidentification' || item == 'specialCharacter'){\n          //langStrs.splice(i,1); //移除\n          delete langStrs[item];\n        }\n        console.log(item);\n        i++;\n      }\n      */\n\n      //console.log(langStrs);\n      if (typeof langStrs['unidentification'] != 'undefined') {\n        delete langStrs['unidentification'];\n      }\n      if (typeof langStrs['specialCharacter'] != 'undefined') {\n        delete langStrs['specialCharacter'];\n      }\n      if (typeof langStrs['number'] != 'undefined') {\n        delete langStrs['number'];\n      }\n\n      //console.log('get end');\n      return langStrs;\n    },\n    // 传入一个char，返回这个char属于什么语种，返回如 chinese_simplified、english  如果返回空字符串，那么表示未获取到是什么语种\n    getCharLanguage: function (charstr) {\n      if (charstr == null || typeof charstr == 'undefined') {\n        return '';\n      }\n      if (this.english(charstr)) {\n        return 'english';\n      } else if (this.specialCharacter(charstr)) {\n        return 'specialCharacter';\n      } else if (this.number(charstr)) {\n        return 'number';\n      } else if (this.chinese_simplified(charstr)) {\n        return 'chinese_simplified';\n      } else if (this.japanese(charstr)) {\n        return 'japanese';\n      } else if (this.korean(charstr)) {\n        return 'korean';\n      } else {\n        console.log('not find is language , char : ' + charstr + ', unicode: ' + charstr.charCodeAt(0).toString(16));\n        return '';\n      }\n    },\n    /*\n     * 对字符串进行分析，分析字符串是有哪几种语言组成。\n     * language : 当前字符的语种，传入如 english\n     * langStrs : 操作的，如 langStrs['english'][0] = '你好'\n     * upLangs  : 当前字符之前的上一个字符的语种是什么，当前字符向上数第一个字符。格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。\n     * upLangsTwo : 当前字符之前的上二个字符的语种是什么 ，当前字符向上数第二个字符。 格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。\n     * chatstr  : 当前字符，如  h\n     */\n    analyse: function (language, langStrs, upLangs, upLangsTwo, charstr) {\n      if (typeof langStrs[language] == 'undefined') {\n        langStrs[language] = new Array();\n      }\n      var index = 0; //当前要存入的数组下标\n      if (typeof upLangs['storage_language'] == 'undefined') {\n        //第一次，那么还没存入值，index肯定为0\n        //console.log('第一次，那么还没存入值，index肯定为0')\n        //console.log(upLangs['language'])\n      } else {\n        //console.log('analyse, charstr : '+charstr+', upLangs :');\n        //console.log(upLangs);\n        //var isEqual = upLangs['storage_language'] == language; //上次跟当前字符是否都是同一个语种（这个字符跟这个字符前一个字符）\n\n        /*\n          英语每个单词之间都会有空格分割. 如果是英文的话，英文跟特殊字符还要单独判断一下，避免拆开，造成翻译不准，单个单词翻译的情况\n          所以如果上次的字符是英文或特殊符号，当前字符是特殊符号(逗号、句号、空格，然后直接笼统就吧特殊符号都算上吧)，那么也将当次的特殊符号变为英文来进行适配\n          示例  \n            hello word  的 \"o w\"\n            hello  word  的 \"  w\"\n            hello  word  的 \"w  \"\n            this is a dog  的 \" a \"\n        */\n        //console.log(language == 'specialCharacter');\n        //如果两个字符类型不一致，但当前字符是英文或连接符时，进行判断\n        /*\n        if(!isEqual){\n          if(language == 'english' || translate.language.connector(charstr)){\n            console.log('1.'+(language == 'english' || translate.language.connector(charstr))+', upLangs str:'+upLangs['charstr']);\n            //上一个字符是英文或连接符\n            //console.log('teshu:'+translate.language.connector(upLangs['charstr'])+', str:'+upLangs['charstr']);\n            if(upLangs['language'] == 'english' || translate.language.connector(upLangs['charstr'])) {\n              console.log('2');\n              //如果上二个字符不存在，那么刚开始，不再上面几种情况之中，直接不用考虑\n              if(typeof(upLangsTwo['language']) != 'undefined'){\n                console.log('3')\n                //上二个字符是空（字符串刚开始），或者是英文\n                if(upLangsTwo['language'] == 'english' || translate.language.connector(upLangsTwo['charstr'])){\n                  //满足这三个条件，那就将这三个拼接到一起\n                  console.log('4/5: '+', two lang:'+upLangsTwo['language']+', str:'+upLangsTwo['charstr'])\n                  isEqual = true;\n                  if(language == 'specialCharacter' && upLangs['language'] == 'specialCharacter' && upLangsTwo['language'] == 'specialCharacter'){\n                    //如果三个都是特殊字符，或后两个是特殊字符，第一个是空（刚开始），那就归入特殊字符\n                    language = 'specialCharacter';\n                    //console.log('4')\n                  }else{\n                    //不然就都归于英文中。\n                    //这里更改是为了让下面能将特殊字符（像是空格逗号等）也一起存入数组\n                    language = 'english';\n                    console.log(5)\n                  }\n                }\n              }\n            }\n          }\n        }\n        */\n\n        /*\n          不判断当前字符，而判断上个字符，是因为当前字符没法获取未知的下个字符。\n        */\n        //if(!isEqual){\n\n        //如果当前字符是连接符\n        if (translate.language.connector(charstr)) {\n          language = upLangs['storage_language'];\n          /*\n          //判断上个字符是否存入了待翻译字符，如要将中文翻译为英文，而上个字符是中文，待翻译，那将连接符一并加入待翻译字符中去，保持句子完整性\n          //判断依据是上个字符存储至的翻译字符语种序列，不是特殊字符，而且也不是要翻译的目标语种，那肯定就是待翻译的，将连接符加入待翻译中一起进行翻译\n          if(upLangs['storage_language'] != 'specialCharacter' && upLangs['storage_language'] != translate.to){\n          \t\n            language = upLangs['storage_language'];\n            console.log('teshu:'+charstr+', 当前字符并入上个字符存储翻译语种:'+upLangs['storage_language']);\n          }\n          */\n        }\n        //}\n\n        //console.log('isEqual:'+isEqual);\n        /*\n        if(isEqual){\n          //跟上次语言一样，那么直接拼接\n          index = langStrs[language].length-1; \n          //但是还有别的特殊情况，v2.1针对英文翻译准确度的适配，会有特殊字符的问题\n          if(typeof(upLangs['storage_language']) != 'undefined' && upLangs['storage_language'] != language){\n            //如果上个字符存入的翻译队列跟当前这个要存入的队列不一个的话，那应该是特殊字符像是逗号句号等导致的，那样还要额外一个数组，不能在存入之前的数组了\n            index = langStrs[language].length; \n          }\n        }else{\n          //console.log('新开');\n          //当前字符跟上次语言不样，那么新开一个数组\n          index = langStrs[language].length;\n          //console.log('++, inde:'+index+',lang:'+language+', length:'+langStrs[language].length)\n        }\n        */\n\n        //当前要翻译的语种跟上个字符要翻译的语种一样，那么直接拼接\n        if (upLangs['storage_language'] == language) {\n          index = langStrs[language].length - 1;\n        } else {\n          //console.log('新开');\n          //当前字符跟上次语言不样，那么新开一个数组\n          index = langStrs[language].length;\n        }\n      }\n      if (typeof langStrs[language][index] == 'undefined') {\n        langStrs[language][index] = new Array();\n        langStrs[language][index]['beforeText'] = '';\n        langStrs[language][index]['afterText'] = '';\n        langStrs[language][index]['text'] = '';\n      }\n      langStrs[language][index]['text'] = langStrs[language][index]['text'] + charstr;\n      /*\n        中文英文混合时，当中文+英文并没有空格间隔，翻译为英文时，会使中文翻译英文的结果跟原本的英文单词连到一块。这里就是解决这种情况\n        针对当前非英文(不需要空格分隔符，像是中文、韩语)，但要翻译为英文（需要空格作为分割符号，像是法语等）时的情况进行判断\n      */\n      //if(translate.language.getLocal() != 'english' && translate.to == 'english'){\n      //当前本地语种的语言是连续的，但翻译的目标语言不是连续的（空格间隔）\n      if (translate.language.wordBlankConnector(translate.language.getLocal()) == false && translate.language.wordBlankConnector(translate.to)) {\n        if (upLangs['storage_language'] != null && typeof upLangs['storage_language'] != 'undefined' && upLangs['storage_language'].length > 0) {\n          //上个字符存在\n          //console.log(upLangs['storage_language']);\n          if (upLangs['storage_language'] != 'specialCharacter') {\n            //上个字符不是特殊字符 （是正常语种。且不会是连接符，连接符都并入了正常语种）\n\n            //if( upLangs['storage_language'] != 'english' && language == 'english'){\n            //上个字符的语言是连续的，但当前字符的语言不是连续的（空格间隔）\n            if (translate.language.wordBlankConnector(upLangs['storage_language']) == false && translate.language.wordBlankConnector(language)) {\n              //上个字符不是英语，当前字符是英语，这种情况要在上个字符后面追加空格，因为当前字符是英文，就不会在执行翻译操作了\n              //console.log(upLangs['language']);\n              langStrs[upLangs['storage_language']][langStrs[upLangs['storage_language']].length - 1]['afterText'] = ' ';\n            } else if (upLangs['storage_language'] == 'english' && language != 'english') {\n              //上个字符是英语，当前字符不是英语，直接在当前字符前面追加空格\n              langStrs[language][index]['beforeText'] = ' ';\n            }\n          }\n        }\n      }\n      var result = new Array();\n      result['langStrs'] = langStrs;\n      result['storage_language'] = language; //实际存入了哪种语种队列\n      //console.log(result);\n      //console.log(langStrs)\n      //console.log(charstr);\n      return result;\n    },\n    /*\n     * 不同于语言，这个只是单纯的连接符。比如英文单词之间有逗号、句号、空格， 汉字之间有逗号句号书名号的。避免一行完整的句子被分割，导致翻译不准确\n     * 单独拿他出来，目的是为了更好的判断计算，提高翻译的准确率\n     */\n    connector: function (str) {\n      /*\n        通用的有 空格、阿拉伯数字\n        1.不间断空格\\u00A0,主要用在office中,让一个单词在结尾处不会换行显示,快捷键ctrl+shift+space ;\n        2.半角空格(英文符号)\\u0020,代码中常用的;\n        3.全角空格(中文符号)\\u3000,中文文章中使用; \n      */\n      if (/.*[\\u0020\\u00A0\\u202F\\u205F\\u3000]+.*$/.test(str)) {\n        return true;\n      }\n      /*\n        U+0030 0 数字 0\n        U+0031 1 数字 1\n        U+0032 2 数字 2\n        U+0033 3 数字 3\n        U+0034 4 数字 4\n        U+0035 5 数字 5\n        U+0036 6 数字 6\n        U+0037 7 数字 7\n        U+0038 8 数字 8\n        U+0039 9 数字 9\n      */\n      if (/.*[\\u0030-\\u0039]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n        英文场景\n        英文逗号、句号\n        这里不包括() 因为这里面的基本属于补充，对语句前后并无强依赖关系\n      \t\n        U+0021 ! 叹号\n        U+0022 \" 双引号\n        U+0023 # 井号\n        U+0024 $ 价钱/货币符号\n        U+0025 % 百分比符号\n        U+0026 & 英文“and”的简写符号\n        U+0027 ' 引号\n        U+002C , 逗号\n        U+002D - 连字号/减号\n        U+002E . 句号\n        U+003A : 冒号\n        U+003B ; 分号\n        U+003F ? 问号\n        U+0040 @ 英文“at”的简写符号\n        */\n      if (/.*[\\u0021\\u0022\\u0023\\u0024\\u0025\\u0026\\u0027\\u002C\\u002D\\u002E\\u003A\\u003B\\u003F\\u0040]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n        中文标点符号\n        名称\tUnicode\t符号\n        句号\t3002\t。\n        问号\tFF1F\t？\n        叹号\tFF01\t！\n        逗号\tFF0C\t，\n        顿号\t3001\t、\n        分号\tFF1B\t；\n        冒号\tFF1A\t：\n        引号\t300C\t「\n            300D\t」\n        引号\t300E\t『\n            300F\t』\n        引号\t2018\t‘\n            2019\t’\n        引号\t201C\t“\n            201D\t”\n        括号\tFF08\t（\n            FF09\t）\n        括号\t3014\t〔\n            3015\t〕\n        括号\t3010\t【\n            3011\t】\n        破折号\t2014\t—\n        省略号\t2026\t…\n        连接号\t2013\t–\n        间隔号\tFF0E\t．\n        书名号\t300A\t《\n            300B\t》\n        书名号\t3008\t〈\n            3009\t〉\n        键盘123前面的那个符号 · 00b7\n      */\n      if (/.*[\\u3002\\uFF1F\\uFF01\\uFF0C\\u3001\\uFF1B\\uFF1A\\u300C\\u300D\\u300E\\u300F\\u2018\\u2019\\u201C\\u201D\\uFF08\\uFF09\\u3014\\u3015\\u3010\\u3011\\u2014\\u2026\\u2013\\uFF0E\\u300A\\u300B\\u3008\\u3009\\u00b7]+.*$/.test(str)) {\n        return true;\n      }\n\n      //不是，返回false\n      return false;\n    },\n    //语种的单词连接符是否需要空格，比如中文、韩文、日语都不需要空格，则返回false, 但是像是英文的单词间需要空格进行隔开，则返回true\n    //如果未匹配到，默认返回true\n    //language：语种，传入如  english\n    wordBlankConnector: function (language) {\n      if (language == null || typeof language == 'undefined') {\n        return true;\n      }\n      switch (language.trim().toLowerCase()) {\n        case 'chinese_simplified':\n          return false;\n        case 'chinese_traditional':\n          return false;\n        case 'korean':\n          return false;\n        case 'japanese':\n          return false;\n      }\n      //其他情况则返回true\n      return true;\n    },\n    //是否包含中文，true:包含\n    chinese_simplified: function (str) {\n      if (/.*[\\u4e00-\\u9fa5]+.*$/.test(str)) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    //是否包含英文，true:包含\n    english: function (str) {\n      if (/.*[\\u0041-\\u005a]+.*$/.test(str)) {\n        return true;\n      } else if (/.*[\\u0061-\\u007a]+.*$/.test(str)) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    //是否包含日语，true:包含\n    japanese: function (str) {\n      if (/.*[\\u0800-\\u4e00]+.*$/.test(str)) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    //是否包含韩语，true:包含\n    korean: function (str) {\n      if (/.*[\\uAC00-\\uD7AF]+.*$/.test(str)) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    //0-9 阿拉伯数字\n    number: function (str) {\n      if (/.*[\\u0030-\\u0039]+.*$/.test(str)) {\n        return true;\n      }\n      return false;\n    },\n    //是否包含特殊字符\n    specialCharacter: function (str) {\n      //如：① ⑴ ⒈ \n      if (/.*[\\u2460-\\u24E9]+.*$/.test(str)) {\n        return true;\n      }\n\n      //如：┊┌┍ ▃ ▄ ▅\n      if (/.*[\\u2500-\\u25FF]+.*$/.test(str)) {\n        return true;\n      }\n\n      //如：㈠  ㎎ ㎏ ㎡\n      if (/.*[\\u3200-\\u33FF]+.*$/.test(str)) {\n        return true;\n      }\n\n      //如：与ANSI对应的全角字符\n      if (/.*[\\uFF00-\\uFF5E]+.*$/.test(str)) {\n        return true;\n      }\n\n      //其它特殊符号\n      if (/.*[\\u2000-\\u22FF]+.*$/.test(str)) {\n        return true;\n      }\n\n      // 、><等符号\n      if (/.*[\\u3001-\\u3036]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n      //阿拉伯数字 0-9\n      if(/.*[\\u0030-\\u0039]+.*$/.test(str)){\n        return true;\n      }\n      */\n\n      /*\n      U+0020 空格\n      U+0021 ! 叹号\n      U+0022 \" 双引号\n      U+0023 # 井号\n      U+0024 $ 价钱/货币符号\n      U+0025 % 百分比符号\n      U+0026 & 英文“and”的简写符号\n      U+0027 ' 引号\n      U+0028 ( 开 左圆括号\n      U+0029 ) 关 右圆括号\n      U+002A * 星号\n      U+002B + 加号\n      U+002C , 逗号\n      U+002D - 连字号/减号\n      U+002E . 句号\n      U+002F / 左斜杠\n      */\n      if (/.*[\\u0020-\\u002F]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n        U+003A : 冒号\n        U+003B ; 分号\n        U+003C < 小于符号\n        U+003D = 等于号\n        U+003E > 大于符号\n        U+003F ? 问号\n        U+0040 @ 英文“at”的简写符号\n        U+0041 A 拉丁字母 A\n        U+0042 B 拉丁字母 B\n        U+0043 C 拉丁字母 C\n        U+0044 D 拉丁字母 D\n        U+0045 E 拉丁字母 E\n        U+0046 F 拉丁字母 F\n        U+0047 G 拉丁字母 G\n        U+0048 H 拉丁字母 H\n        U+0049 I 拉丁字母 I\n        U+004A J 拉丁字母 J\n        U+004B K 拉丁字母 K\n        U+004C L 拉丁字母 L\n        U+004D M 拉丁字母 M\n        U+004E N 拉丁字母 N\n        U+004F O 拉丁字母 O\n        U+0050 P 拉丁字母 P\n        U+0051 Q 拉丁字母 Q\n        U+0052 R 拉丁字母 R\n        U+0053 S 拉丁字母 S\n        U+0054 T 拉丁字母 T\n        U+0055 U 拉丁字母 U\n        U+0056 V 拉丁字母 V\n        U+0057 W 拉丁字母 W\n        U+0058 X 拉丁字母 X\n        U+0059 Y 拉丁字母 Y\n        U+005A Z 拉丁字母 Z\n        U+005B [ 开 方括号\n        U+005C \\ 右斜杠\n        U+005D ] 关 方括号\n        U+005E ^ 抑扬（重音）符号\n        U+005F _ 底线\n        U+0060 ` 重音符\n        U+0061 a 拉丁字母 a\n        U+0062 b 拉丁字母 b\n        U+0063 c 拉丁字母 c\n        U+0064 d 拉丁字母 d\n        U+0065 e 拉丁字母 e\n        U+0066 f 拉丁字母 f\n        U+0067 g 拉丁字母 g\n        U+0068 h 拉丁字母 h\n        U+0069 i 拉丁字母 i\n        U+006A j 拉丁字母 j\n        U+006B k 拉丁字母 k\n        U+006C l 拉丁字母 l（L的小写）\n        U+006D m 拉丁字母 m\n        U+006E n 拉丁字母 n\n        U+006F o 拉丁字母 o\n        U+0070 p 拉丁字母 p\n        U+0071 q 拉丁字母 q\n        U+0072 r 拉丁字母 r\n        U+0073 s 拉丁字母 s\n        U+0074 t 拉丁字母 t\n        U+0075 u 拉丁字母 u\n        U+0076 v 拉丁字母 v\n        U+0077 w 拉丁字母 w\n        U+0078 x 拉丁字母 x\n        U+0079 y 拉丁字母 y\n        U+007A z 拉丁字母 z\n        U+007B { 开 左花括号\n        U+007C | 直线\n        U+007D } 关 右花括号\n        U+007E ~ 波浪纹\n      */\n      if (/.*[\\u003A-\\u007E]+.*$/.test(str)) {\n        return true;\n      }\n\n      //空白字符，\\u0009\\u000a + https://cloud.tencent.com/developer/article/2128593\n      if (/.*[\\u0009\\u000a\\u0020\\u00A0\\u1680\\u180E\\u202F\\u205F\\u3000\\uFEFF]+.*$/.test(str)) {\n        return true;\n      }\n      if (/.*[\\u2000-\\u200B]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n      拉丁字母\n      代码 显示 描述\n      U+00A1 ¡ 倒转的叹号\n      U+00A2 ¢ （货币单位）分钱、毫子\n      U+00A3 £ （货币）英镑\n      U+00A4 ¤ （货币）当货币未有符号时以此替代\n      U+00A5 ¥ （货币）日元\n      U+00A6 ¦ 两条断开的直线\n      U+00A7 § 文件分不同部分\n      U+00A8 ¨ （语言）分音\n      U+00A9 © 版权符\n      U+00AA ª （意大利文、葡萄牙文、西班牙文）阴性序数\n      U+00AB « 双重角形引号\n      U+00AC ¬ 逻辑非\n      U+00AE ® 商标\n      U+00AF ¯ 长音\n      U+00B0 ° 角度\n      U+00B1 ± 正负号\n      U+00B2 ² 二次方\n      U+00B3 ³ 三次方\n      U+00B4 ´ 锐音符\n      U+00B5 µ 百万分之一，10?6\n      U+00B6 ¶ 文章分段\n      U+00B7 · 间隔号\n      U+00B8 ¸ 软音符\n      U+00B9 ¹ 一次方\n      U+00BA º （意大利文、葡萄牙文、西班牙文）阳性序数\n      U+00BB » 指向右的双箭头\n      U+00BC ¼ 四分之一\n      U+00BD ½ 二分之一\n      U+00BE ¾ 四分之三\n      U+00BF ¿ 倒转的问号\n      U+00C1 Á 在拉丁字母 A 上加锐音符\n      U+00C2 Â 在拉丁字母 A 上加抑扬符“^”\n      U+00C3 Ã 在拉丁字母 A 上加“~”\n      U+00C4 Ä 在拉丁字母 A 上加分音符“..”\n      U+00C5 Å 在拉丁字母 A 上加角度符“°”\n      U+00C6 Æ 拉丁字母 A、E 的混合\n      U+00C7 Ç 在拉丁字母 C 下加软音符\n      U+00C8 È 在拉丁字母 E 上加重音符\n      U+00C9 É 在拉丁字母 E 上加锐音符\n      U+00CA Ê 在拉丁字母 E 上加抑扬符\n      U+00CB Ë 在拉丁字母 E 上加分音符\n      U+00CC Ì 在拉丁字母 I 上加重音符\n      U+00CD Í 在拉丁字母 I 上加锐音符\n      U+00CE Î 在拉丁字母 I 上加抑扬符\n      U+00CF Ï 在拉丁字母 I 上加分音符\n      U+00D0 Ð 古拉丁字母，现只有法罗文和冰岛文和越南语使用\n      U+00D1 Ñ 在拉丁字母 N 上加波浪纹“~”\n      U+00D2 Ò 在拉丁字母 O 上加重音符\n      U+00D3 Ó 在拉丁字母 O 上加锐音符\n      U+00D4 Ô 在拉丁字母 O 上加抑扬符\n      U+00D5 Õ 在拉丁字母 O 上加波浪纹“~”\n      U+00D6 Ö 在拉丁字母 O 上加分音符\n      U+00D7 × 乘号，亦可拖按“Alt”键，同时按“41425”五键\n      U+00D8 Ø 在拉丁字母 O 由右上至左下加对角斜线“/”\n      U+00D9 Ù 在拉丁字母 U 上加重音符\n      U+00DA Ú 在拉丁字母 U 上加锐音符\n      U+00DB Û 在拉丁字母 U 上加抑扬符\n      U+00DC Ü 在拉丁字母 U 上加分音符\n      U+00DD Ý 在拉丁字母 Y 上加锐音符\n      U+00DE Þ 古拉丁字母，现已被“Th”取替\n      U+00DF ß 德文字母\n      U+00E0 à 在拉丁字母 a 上加重音符\n      U+00E1 á 在拉丁字母 a 上加锐音符\n      U+00E2 â 在拉丁字母 a 上加抑扬符\n      U+00E3 ã 在拉丁字母 a 上加波浪纹“~”\n      U+00E4 ä 在拉丁字母 a 上加分音符\n      U+00E5 å 在拉丁字母 a 上加角度符“°”\n      U+00E6 æ 拉丁字母 a、e 的混合\n      U+00E7 ç 在拉丁字母 c 下加软音符\n      U+00E8 è 在拉丁字母 e 上加锐音符\n      U+00E9 é 在拉丁字母 e 上加重音符\n      U+00EA ê 在拉丁字母 e 上加抑扬符\n      U+00EB ë 在拉丁字母 e 上加分音符\n      U+00EC ì 在拉丁字母 i 上加重音符\n      U+00ED í 在拉丁字母 i 上加锐音符\n      U+00EE î 在拉丁字母 i 上加抑扬符\n      U+00EF ï 在拉丁字母 i 上加分音符\n      U+00F0 ð 古拉丁字母\n      U+00F1 ñ 在拉丁字母 n 上加波浪纹“~”\n      U+00F2 ò 在拉丁字母 o 上加重音符\n      U+00F3 ó 在拉丁字母 o 上加锐音符\n      U+00F4 ô 在拉丁字母 o 上加抑扬符\n      U+00F5 õ 在拉丁字母 o 上加波浪纹“~”\n      U+00F6 ö 在拉丁字母 o 上加分音符\n      U+00F7 ÷ 除号，亦可拖按“Alt”键，同时按“41426”五键\n      U+00F8 ø 在拉丁字母 o 由右上至左下加对角斜线“/”\n      U+00F9 ù 在拉丁字母 u 上加重音符\n      U+00FA ú 在拉丁字母 u 上加锐音符\n      U+00FB ? 在拉丁字母 u 上加抑扬符\n      U+00FC ü 在拉丁字母 u 上加分音符\n      U+00FD ý 在拉丁字母 y 上加锐音符\n      U+00FE þ 古拉丁字母，现已被“th”取替\n      U+00FF ü 在拉丁字母 u 上加分音符\n      拉丁字母（扩展 A）\n      代码 显示 描述\n      U+0100 Ā 在拉丁字母 A 上加长音符\n      U+0101 ā 在拉丁字母 a 上加长音符\n      U+0102 Ă 在拉丁字母 A 上加短音符\n      U+0103 ă 在拉丁字母 a 上加短音符\n      U+0104 Ą 在拉丁字母 A 上加反尾形符\n      U+0105 ą 在拉丁字母 a 上加反尾形符\n      拉丁字母（扩展 C）\n      代码 显示 描述\n      U+2C60 Ⱡ 在拉丁字母“L”中间加两条横线“=”\n      U+2C61 ⱡ 在拉丁字母“l”（L 的小写）中间加两条横线“=”\n      U+2C62 Ɫ 在拉丁字母“L”（大写）中间加一条波浪线“~”\n      U+2C63 Ᵽ 在拉丁字母“P”中间加一条横线“-”\n      U+2C64 Ɽ 在拉丁字母“R”下加一条尾巴\n      U+2C65 ⱥ 在拉丁字母“a”上加一条对角斜线“/”\n      U+2C66 ⱦ 在拉丁字母“t”上加一条对角斜线“/”\n      U+2C67 Ⱨ 在拉丁字母“H”下加一条尾巴\n      U+2C68 ⱨ 在拉丁字母“h”下加一条尾巴\n      U+2C69 Ⱪ 在拉丁字母“K”下加一条尾巴\n      U+2C6A ⱪ 在拉丁字母“k”下加一条尾巴\n      U+2C6B Ⱬ 在拉丁字母“Z”下加一条尾巴\n      U+2C6C ⱬ 在拉丁字母“z”下加一条尾巴\n      U+2C74 ⱴ 在拉丁字母“v”的起笔加一个弯勾\n      U+2C75 Ⱶ 拉丁字母“H”的左半部\n      U+2C76 ⱶ 拉丁字母“h”的左半部\n      U+2C77 ⱷ 希腊字母“φ”的上半部\n      */\n      if (/.*[\\u00A1-\\u0105]+.*$/.test(str)) {\n        return true;\n      }\n      if (/.*[\\u2C60-\\u2C77]+.*$/.test(str)) {\n        return true;\n      }\n      return false;\n    }\n  },\n  //用户第一次打开网页时，自动判断当前用户所在国家使用的是哪种语言，来自动进行切换为用户所在国家的语种。\n  //如果使用后，第二次在用，那就优先以用户所选择的为主\n  executeByLocalLanguage: function () {\n    translate.request.post(translate.request.api.host + translate.request.api.ip + '?v=' + translate.version, {}, function (data) {\n      //console.log(data); \n      if (data.result == 0) {\n        console.log('==== ERROR 获取当前用户所在区域异常 ====');\n        console.log(data.info);\n        console.log('==== ERROR END ====');\n      } else {\n        translate.setUseVersion2();\n        translate.storage.set('to', data.language); //设置目标翻译语言\n        translate.to = data.language; //设置目标语言\n        translate.selectLanguageTag;\n        translate.execute(); //执行翻译\n      }\n    });\n  },\n  util: {\n    /* 生成一个随机UUID，复制于 https://gitee.com/mail_osc/kefu.js */\n    uuid: function () {\n      var d = new Date().getTime();\n      if (window.performance && typeof window.performance.now === \"function\") {\n        d += performance.now(); //use high-precision timer if available\n      }\n      var uuid = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n      });\n      return uuid;\n    },\n    //判断字符串中是否存在tag标签。 true存在\n    findTag: function (str) {\n      var reg = /<[^>]+>/g;\n      return reg.test(str);\n    },\n    //传入一个数组，从数组中找出现频率最多的一个返回。 如果多个频率出现的次数一样，那会返回多个\n    arrayFindMaxNumber: function (arr) {\n      // 储存每个元素出现的次数\n      var numbers = {};\n\n      // 储存出现最多次的元素\n      var maxStr = [];\n\n      // 储存最多出现的元素次数\n      var maxNum = 0;\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (!numbers[arr[i]]) {\n          numbers[arr[i]] = 1;\n        } else {\n          numbers[arr[i]]++;\n        }\n        if (numbers[arr[i]] > maxNum) {\n          maxNum = numbers[arr[i]];\n        }\n      }\n      for (var item in numbers) {\n        if (numbers[item] === maxNum) {\n          maxStr.push(item);\n        }\n      }\n      return maxStr;\n    },\n    //对字符串进行hash化，目的取唯一值进行标识\n    hash: function (str) {\n      if (str == null || typeof str == 'undefined') {\n        return str;\n      }\n      var hash = 0,\n        i,\n        chr;\n      if (str.length === 0) {\n        return hash;\n      }\n      for (i = 0; i < str.length; i++) {\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0; // Convert to 32bit integer\n      }\n      return hash + '';\n    },\n    //去除一些指定字符，如换行符。 如果传入的是null，则返回空字符串\n    charReplace: function (str) {\n      if (str == null) {\n        return '';\n      }\n      str = str.trim();\n      str = str.replace(/\\t|\\n|\\v|\\r|\\f/g, ''); //去除换行符等\n      //str = str.replace(/&/g, \"%26\"); //因为在提交时已经进行了url编码了\n      return str;\n    },\n    //RegExp相关\n    regExp: {\n      // new RegExp(pattern, resultText); 中的 pattern 字符串的预处理\n      pattern: function (str) {\n        //str = str.replace(/'/g,'\\\\\\'');\n        str = str.replace(/\\\"/g, '\\\\\\\"');\n        //str = str.replace(/./g,'\\\\\\.');\n        str = str.replace(/\\?/g, '\\\\\\?');\n        str = str.replace(/\\$/g, '\\\\\\$');\n        return str;\n      },\n      // new RegExp(pattern, resultText); 中的 resultText 字符串的预处理\n      resultText: function (str) {\n        //str = str.replace(/&quot;/g,\"\\\"\");\n        //str = str.replace(/'/g,\"\\\\\\'\");\n        //str = str.replace(/\"/g,\"\\\\\\\"\");\n        return str;\n      }\n    },\n    //获取URL的GET参数。若没有，返回\"\"\n    getUrlParam: function (name) {\n      var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\");\n      var r = window.location.search.substr(1).match(reg);\n      if (r != null) return unescape(r[2]);\n      return \"\";\n    },\n    /**\n     * 同步加载JS，加载过程中会阻塞，加载完毕后继续执行后面的。\n     * url: 要加载的js的url\n     */\n    synchronizesLoadJs: function (url) {\n      var xmlHttp = null;\n      if (window.ActiveXObject) {\n        //IE  \n        try {\n          //IE6以及以后版本中可以使用  \n          xmlHttp = new ActiveXObject(\"Msxml2.XMLHTTP\");\n        } catch (e) {\n          //IE5.5以及以后版本可以使用  \n          xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n      } else if (window.XMLHttpRequest) {\n        //Firefox，Opera 8.0+，Safari，Chrome  \n        xmlHttp = new XMLHttpRequest();\n      }\n      //采用同步加载  \n      xmlHttp.open(\"GET\", url, false);\n      //发送同步请求，如果浏览器为Chrome或Opera，必须发布后才能运行，不然会报错  \n      xmlHttp.send(null);\n      //4代表数据发送完毕  \n      if (xmlHttp.readyState == 4) {\n        //0为访问的本地，200到300代表访问服务器成功，304代表没做修改访问的是缓存  \n        if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 0 || xmlHttp.status == 304) {\n          var myBody = document.getElementsByTagName(\"HTML\")[0];\n          var myScript = document.createElement(\"script\");\n          myScript.language = \"javascript\";\n          myScript.type = \"text/javascript\";\n          try {\n            //IE8以及以下不支持这种方式，需要通过text属性来设置  \n            myScript.appendChild(document.createTextNode(xmlHttp.responseText));\n          } catch (ex) {\n            myScript.text = xmlHttp.responseText;\n          }\n          myBody.appendChild(myScript);\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    },\n    //加载 msg.js\n    loadMsgJs: function () {\n      if (typeof msg != 'undefined') {\n        return;\n      }\n      translate.util.synchronizesLoadJs('http://res.zvo.cn/msg/msg.js');\n    },\n    /*\n      对一个对象，按照对象的key的长度进行排序，越长越在前面\n    */\n    objSort: function (obj) {\n      // 获取对象数组的所有 key，并转换为普通数组\n      var keys = Array.from(Object.keys(obj));\n\n      // 对 key 数组进行排序\n      keys.sort(function (a, b) {\n        return b.length - a.length;\n      });\n\n      // 定义一个新的对象数组，用来存储排序后的结果\n      var sortedObj = new Array();\n\n      // 遍历排序后的 key 数组，将对应的值复制到新的对象数组中，并删除原来的对象数组中的键值对\n      for (var key of keys) {\n        sortedObj[key] = obj[key];\n      }\n      return sortedObj;\n    }\n  },\n  //request请求来源于 https://github.com/xnx3/request\n  request: {\n    //相关API接口方面\n    api: {\n      /**\n       * 翻译接口请求的域名主机 host\n       * 格式注意前面要带上协议如 https:// 域名后要加 /\n       */\n      host: 'https://api.translate.zvo.cn/',\n      language: 'language.json',\n      //获取支持的语种列表接口\n      translate: 'translate.json',\n      //翻译接口\n      ip: 'ip.json' //根据用户当前ip获取其所在地的语种\n    },\n    /**\n     * post请求\n     * @param url 请求的接口URL，传入如 http://www.xxx.com/a.php\n     * @param data 请求的参数数据，传入如 {\"goodsid\":\"1\", \"author\":\"管雷鸣\"}\n     * @param func 请求完成的回调，传入如 function(data){ console.log(data); }\n     */\n    post: function (url, data, func) {\n      var headers = {\n        'content-type': 'application/x-www-form-urlencoded'\n      };\n      this.send(url, data, func, 'post', true, headers, null);\n    },\n    /**\n     * 发送请求\n     * url 请求的url\n     * data 请求的数据，如 {\"author\":\"管雷鸣\",'site':'www.guanleiming.com'} \n     * func 请求完成的回调，传入如 function(data){}\n     * method 请求方式，可传入 post、get\n     * isAsynchronize 是否是异步请求， 传入 true 是异步请求，传入false 是同步请求\n     * headers 设置请求的header，传入如 {'content-type':'application/x-www-form-urlencoded'};\n     * abnormalFunc 响应异常所执行的方法，响应码不是200就会执行这个方法 ,传入如 function(xhr){}\n     */\n    send: function (url, data, func, method, isAsynchronize, headers, abnormalFunc) {\n      //post提交的参数\n      var params = '';\n      if (data != null) {\n        for (var index in data) {\n          if (params.length > 0) {\n            params = params + '&';\n          }\n          params = params + index + '=' + data[index];\n        }\n      }\n      var xhr = null;\n      try {\n        xhr = new XMLHttpRequest();\n      } catch (e) {\n        xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n      //2.调用open方法（true----异步）\n      xhr.open(method, url, isAsynchronize);\n      //设置headers\n      if (headers != null) {\n        for (var index in headers) {\n          xhr.setRequestHeader(index, headers[index]);\n        }\n      }\n      xhr.send(params);\n      //4.请求状态改变事件\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          if (xhr.status == 200) {\n            //请求正常，响应码 200\n            var json = null;\n            try {\n              json = JSON.parse(xhr.responseText);\n            } catch (e) {\n              console.log(e);\n            }\n            if (json == null) {\n              func(xhr.responseText);\n            } else {\n              func(json);\n            }\n          } else {\n            if (abnormalFunc != null) {\n              abnormalFunc(xhr);\n            }\n          }\n        }\n      };\n    }\n  },\n  //存储，本地缓存\n  storage: {\n    set: function (key, value) {\n      localStorage.setItem(key, value);\n    },\n    get: function (key) {\n      return localStorage.getItem(key);\n    }\n  },\n  //针对图片进行相关的语种图片替换\n  images: {\n    /* 要替换的图片队列，数组形态，其中某个数组的：\n      key：\"/uploads/allimg/160721/2-160H11URA25-lp.jpg\"; //旧图片，也就是原网站本身的图片。也可以绝对路径，会自动匹配 img src 的值，匹配时会进行完全匹配\n      value：\"https://xxx.com/abc_{language}.jpg\" //新图片，要被替换为的新图片。新图片路径需要为绝对路径，能直接访问到的。其中 {language} 会自动替换为当前要显示的语种。比如你要将你中文网站翻译为繁体中文，那这里会自动替换为：https://xxx.com/abc_chinese_traditional.jpg  有关{language}的取值，可查阅 http://api.translate.zvo.cn/doc/language.json.html 其中的语言标识id便是\n    */\n    queues: [],\n    /*\n      向图片替换队列中追加要替换的图片\n      传入格式如：\n    \t\n      translate.images.add({\n        \"/uploads/a.jpg\":\"https://www.zvo.cn/a_{language}.jpg\",\n        \"/uploads/b.jpg\":\"https://www.zvo.cn/b_{language}.jpg\",\n      });\n    \t\n      参数说明：\n      key  //旧图片，也就是原网站本身的图片。也可以绝对路径，会自动匹配 img src 的值，匹配时会进行完全匹配\n      value //新图片，要被替换为的新图片。新图片路径需要为绝对路径，能直接访问到的。其中 {language} 会自动替换为当前要显示的语种。比如你要将你中文网站翻译为繁体中文，那这里会自动替换为：https://xxx.com/abc_chinese_traditional.jpg  有关{language}的取值，可查阅 http://api.translate.zvo.cn/doc/language.json.html 其中的语言标识id便是\n    */\n    add: function (queueArray) {\n      /*\n      translate.images.queues[translate.images.queues.length] = {\n        old:oldImage,\n        new:newImage\n      }\n      */\n      for (var key in queueArray) {\n        translate.images.queues[key] = queueArray[key];\n      }\n    },\n    //执行图片替换操作，将原本的图片替换为跟翻译语种一样的图片\n    execute: function () {\n      if (Object.keys(translate.images.queues).length < 1) {\n        //如果没有，那么直接取消图片的替换扫描\n        return;\n      }\n      var imgs = document.getElementsByTagName('img');\n      for (var i = 0; i < imgs.length; i++) {\n        var img = imgs[i];\n        if (typeof img.src == 'undefined' || img.src == null || img.src.length == 0) {\n          continue;\n        }\n        for (var key in translate.images.queues) {\n          var oldImage = key; //原本的图片src\n          var newImage = translate.images.queues[key]; //新的图片src，要替换为的\n          //console.log('queue+'+oldImage);\n          if (oldImage == img.src) {\n            //console.log('发现匹配图片:'+img.src);\n            /*\n            //判断当前元素是否在ignore忽略的tag、id、class name中\n            if(translate.ignore.isIgnore(node)){\n              console.log('node包含在要忽略的元素中：');\n              console.log(node);\n              continue;\n            }\n            */\n\n            //没在忽略元素里，可以替换\n            img.src = newImage.replace(new RegExp('{language}', 'g'), translate.to);\n          }\n        }\n      }\n\n      /********** 还要替换style中的背景图 */\n      /*\n              var elements = document.querySelectorAll('[style*=\"background-image\"], [style*=\"background\"]');\n        for (var i = 0; i < elements.length; i++) {\n            var style = window.getComputedStyle(elements[i]);\n            var backgroundImage = style.getPropertyValue('background-image');\n            if (backgroundImage !== 'none') {\n                console.log(backgroundImage);\n            }\n        }\n       */\n    }\n  },\n  /*\n    划词翻译，鼠标在网页中选中一段文字，会自动出现对应翻译后的文本\n    有网友 https://gitee.com/huangguishen 提供。\n    详细使用说明参见：http://translate.zvo.cn/41557.html\n  */\n  selectionTranslate: {\n    selectionX: 0,\n    selectionY: 0,\n    callTranslate: function (event) {\n      let curSelection = window.getSelection();\n      //相等认为没有划词\n      if (curSelection.anchorOffset == curSelection.focusOffset) return;\n      let translateText = window.getSelection().toString();\n\n      //简单Copy原有代码了\n      var url = translate.request.api.host + translate.request.api.translate + '?v=' + translate.version;\n      var data = {\n        from: translate.language.getLocal(),\n        to: translate.to,\n        text: encodeURIComponent(JSON.stringify([translateText]))\n      };\n      translate.request.post(url, data, function (data) {\n        if (data.result == 0) return;\n        let curTooltipEle = document.querySelector('#translateTooltip');\n        curTooltipEle.innerText = data.text[0];\n        curTooltipEle.style.top = selectionY + 20 + \"px\";\n        curTooltipEle.style.left = selectionX + 50 + \"px\";\n        curTooltipEle.style.display = \"\";\n      });\n    },\n    start: function () {\n      //新建一个tooltip元素节点用于显示翻译\n      let tooltipEle = document.createElement('span');\n      tooltipEle.innerText = '';\n      tooltipEle.setAttribute('id', 'translateTooltip');\n      tooltipEle.setAttribute('style', 'background-color:black;color:#fff;text-align:center;border-radius:6px;padding:5px;position:absolute;z-index:999;top:150%;left:50%; ');\n      //把元素节点添加到body元素节点中成为其子节点，放在body的现有子节点的最后\n      document.body.appendChild(tooltipEle);\n      //监听鼠标按下事件，点击起始点位置作为显示翻译的位置点\n      document.addEventListener('mousedown', event => {\n        selectionX = event.pageX;\n        selectionY = event.pageY;\n      }, false);\n      //监听鼠标弹起事件，便于判断是否处于划词\n      document.addEventListener('mouseup', translate.selectionTranslate.callTranslate, false);\n      //监听鼠标点击事件，隐藏tooltip，此处可优化\n      document.addEventListener('click', event => {\n        document.querySelector('#translateTooltip').style.display = \"none\";\n      }, false);\n    }\n  }\n\n  /**************************** v2.0 end */\n};\nconsole.log('Two lines of js html automatic translation, page without change, no language configuration file, no API Key, SEO friendly! Open warehouse : https://github.com/xnx3/translate');\n\n//这个只是v1使用到\ntry {\n  translate.init();\n  //translate.execute();\n} catch (e) {\n  console.log(e);\n}\nexport default translate;","map":{"version":3,"names":["translate","version","useVersion","setUseVersion2","includedLanguages","resourcesUrl","selectLanguageTag","show","languages","alreadyRender","selectOnChange","event","language","target","value","changeLanguage","render","document","getElementById","body_trans","getElementsByTagName","div","createElement","id","appendChild","request","post","api","host","data","result","console","log","info","onchange","selectLanguage","className","i","list","length","option","setAttribute","langs_indexof","toLowerCase","indexOf","to","getLocal","createTextNode","name","window","addEventListener","attachEvent","localLanguage","googleTranslateElementInit","selectId","google","TranslateElement","pageLanguage","layout","init","protocol","location","execute_v1","head0","script","type","src","setCookie","cookieString","escape","cookie","getCookie","strCookie","arrCookie","split","arr","unescape","currentLanguage","cookieValue","substr","lastIndexOf","languageName","v1","check","googtrans","s","fanDomain","Date","reload","isReload","storage","set","execute","autoDiscriminateLocalLanguage","documents","ignore","tag","class","isIgnore","ele","parentNode","maxnumber","nodename","element","getNodeName","classNames","trim","c_index","nomenclature","Array","old_Data","alert","append","from","properties","line","line_index","item","kvs","key","util","objSort","get","dispose","str","originalText","translateText","index","beforeChar","lang","getCharLanguage","afterChar","replace","RegExp","office","export","getCurrent","text","uuid","nodeQueue","queueValue","hash","original","loadMsgJs","msg","popups","width","height","padding","showPanel","panel","button","onclick","innerHTML","textdiv","body","setAutoDiscriminateLocalLanguage","setDocuments","getDocuments","all","listener","isExecuteFinish","isStart","start","temp_linstenerStartInterval","setInterval","readyState","clearInterval","addListener","config","attributes","childList","subtree","callback","mutationsList","observer","mutation","addedNodes","push","apply","MutationObserver","docs","docs_index","doc","observe","renderTaskFinish","renderTask","constructor","taskQueue","nodes","add","node","resultText","attribute","nodeAnaly","nodeAnalyse","tasks","task","sort","a","b","node_index","task_index","to_storage","e","executeByLocalLanguage","images","whileNodes","translateTextArray","translateHashArray","originalWord","cacheHash","cache","fanyiLangs","temp_executeFinishNumber","temp_executeFinishInterval","lang_index","url","encodeURIComponent","JSON","stringify","analyse","regExp","pattern","parentNodename","nodeValue","input_value_node","nodeAttributeName","content","alt","nodeName","now","addNodeToQueue","childNodes","findNode","parentNodeName","findTag","langs","word_index","word","beforeText","afterText","isSameNode","nodesIndex","local","setLocal","autoRecognitionLocalLanguage","setDefaultTo","setUrlParamControl","paramName","paramValue","getUrlParam","bodyText","outerText","charstr","charAt","newLangs","arrayFindMaxNumber","splice","langStrs","upLangs","upLangsTwo","english","specialCharacter","number","chinese_simplified","japanese","korean","charCodeAt","toString","connector","wordBlankConnector","test","ip","d","getTime","performance","c","r","Math","random","floor","reg","numbers","maxStr","maxNum","len","chr","charReplace","search","match","synchronizesLoadJs","xmlHttp","ActiveXObject","XMLHttpRequest","open","send","status","myBody","myScript","responseText","ex","obj","keys","Object","sortedObj","func","headers","method","isAsynchronize","abnormalFunc","params","xhr","setRequestHeader","onreadystatechange","json","parse","localStorage","setItem","getItem","queues","queueArray","imgs","img","oldImage","newImage","selectionTranslate","selectionX","selectionY","callTranslate","curSelection","getSelection","anchorOffset","focusOffset","curTooltipEle","querySelector","innerText","style","top","left","display","tooltipEle","pageX","pageY"],"sources":["D:/HuaweiMoveData/Users/13565650660/Desktop/WebSite/display_web/node_modules/i18n-jsautotranslate/index.js"],"sourcesContent":["/*\n\n  国际化，网页自动翻译。\n  作者：管雷鸣\n  开原仓库：https://github.com/xnx3/translate\n\n */\nconst translate = {\n  /*\n   * 当前的版本\n   */\n  version: '2.6.0.20230816',\n  useVersion: 'v1',\t//当前使用的版本，默认使用v1. 可使用 setUseVersion2(); //来设置使用v2\n  setUseVersion2: function () {\n    translate.useVersion = 'v2';\n  },\n  /*\n   * 翻译的对象，也就是 new google.translate.TranslateElement(...)\n   */\n  translate: null,\n  /*\n   * 支持哪些语言切换，包括：de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr\n   * 已废弃，请使用 translate.selectLanguageTag.languages \n   */\n  includedLanguages: 'zh-CN,zh-TW,en',\n  /*\n   * 资源文件url的路径\n     */\n  resourcesUrl: '//res.zvo.cn/translate',\n\n  /**\n   * 默认出现的选择语言的 select 选择框，可以通过这个选择切换语言。\n   */\n  selectLanguageTag: {\n    /* 是否显示 select选择语言的选择框，true显示； false不显示。默认为true */\n    show: true,\n    /* \n      支持哪些语言切换\n      v1.x 版本包括：de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr \n      v2.x 版本根据后端翻译服务不同，支持的语言也不同。具体支持哪些，可通过 http://api.translate.zvo.cn/doc/language.json.html 获取 （如果您私有部署的，将请求域名换为您自己私有部署的域名）\n    */\n    languages: '',\n    alreadyRender: false, //当前是否已渲染过了 true为是 v2.2增加\n    selectOnChange: function (event) {\n      var language = event.target.value;\n      translate.changeLanguage(language);\n    },\n    render: function () { //v2增加\n      if (translate.selectLanguageTag.alreadyRender) {\n        return;\n      }\n      translate.selectLanguageTag.alreadyRender = true;\n\n      //判断如果不显示select选择语言，直接就隐藏掉\n      if (!translate.selectLanguageTag.show) {\n        return;\n      }\n\n      //判断translate 的id是否存在，不存在就创建一个\n      if (document.getElementById('translate') == null) {\n        var body_trans = document.getElementsByTagName('body')[0];\n        var div = document.createElement(\"div\");  //创建一个script标签\n        div.id = \"translate\";\n        body_trans.appendChild(div);\n      } else {\n        //存在，那么判断一下 select是否存在，要是存在就不重复创建了\n        if (document.getElementById('translateSelectLanguage') != null) {\n          //select存在了，就不重复创建了\n          return;\n        }\n      }\n\n      //从服务器加载支持的语言库\n      translate.request.post(translate.request.api.host + translate.request.api.language + '?v=' + translate.version, {}, function (data) {\n        if (data.result == 0) {\n          console.log('load language list error : ' + data.info);\n          return;\n        }\n\n        //select的onchange事件\n        var onchange = function (event) { translate.selectLanguageTag.selectOnChange(event); }\n\n        //创建 select 标签\n        var selectLanguage = document.createElement(\"select\");\n        selectLanguage.id = 'translateSelectLanguage';\n        selectLanguage.className = 'translateSelectLanguage';\n        for (var i = 0; i < data.list.length; i++) {\n          var option = document.createElement(\"option\");\n          option.setAttribute(\"value\", data.list[i].id);\n\n          //判断 selectLanguageTag.languages 中允许使用哪些\n\n          if (translate.selectLanguageTag.languages.length > 0) {\n            //设置了自定义显示的语言\n\n            //都转小写判断\n            var langs_indexof = (',' + translate.selectLanguageTag.languages + ',').toLowerCase();\n            console.log(langs_indexof)\n            if (langs_indexof.indexOf(',' + data.list[i].id.toLowerCase() + ',') < 0) {\n              //没发现，那不显示这个语种，调出\n              continue\n            }\n          }\n\n          /*判断默认要选中哪个语言*/\n          if (translate.to != null && typeof (translate.to) != 'undefined' && translate.to.length > 0) {\n            //设置了目标语言，那就进行判断显示目标语言\n\n            if (translate.to == data.list[i].id) {\n              option.setAttribute(\"selected\", 'selected');\n            }\n          } else {\n            //没设置目标语言，那默认选中当前本地的语种\n            if (data.list[i].id == translate.language.getLocal()) {\n              option.setAttribute(\"selected\", 'selected');\n            }\n          }\n\n          option.appendChild(document.createTextNode(data.list[i].name));\n          selectLanguage.appendChild(option);\n        }\n        //增加 onchange 事件\n        if (window.addEventListener) { // Mozilla, Netscape, Firefox \n          selectLanguage.addEventListener('change', onchange, false);\n        } else { // IE \n          selectLanguage.attachEvent('onchange', onchange);\n        }\n        //将select加入进网页显示\n        document.getElementById('translate').appendChild(selectLanguage);\n        /*\n        try{\n          document.getElementById('translateSelectLanguage').style.width = '94px';\n        }catch(e){ console.log(e);} \n        */\n      });\n\n\n    }\n  },\n\n  /*\n   * 当前本地语言\n   */\n  //localLanguage:'zh-CN',\n  localLanguage: 'zh-CN',\n\n  /**\n   * google翻译执行的\n   */\n  googleTranslateElementInit: function () {\n    var selectId = '';\n    if (document.getElementById('translate') != null) {\t// && document.getElementById('translate').innerHTML.indexOf('translateSelectLanguage') > 0\n      //已经创建过了,存在\n      selectId = 'translate';\n    }\n\n    translate.translate = new google.translate.TranslateElement(\n      {\n        //这参数没用，请忽略\n        pageLanguage: 'zh-CN',\n        //一共80种语言选择，这个是你需要翻译的语言，比如你只需要翻译成越南和英语，这里就只写en,vi\n        //includedLanguages: 'de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr',\n        includedLanguages: translate.selectLanguageTag.languages,\n        //选择语言的样式，这个是面板，还有下拉框的样式，具体的记不到了，找不到api~~  \n        layout: 0,\n        //自动显示翻译横幅，就是翻译后顶部出现的那个，有点丑，设置这个属性不起作用的话，请看文章底部的其他方法\n        //autoDisplay: false, \n        //disableAutoTranslation:false,\n        //还有些其他参数，由于原插件不再维护，找不到详细api了，将就了，实在不行直接上dom操作\n      },\n      selectId //触发按钮的id\n    );\n  },\n\n  /**\n   * 初始化，如加载js、css资源\n   */\n  init: function () {\n    /****** 先判断当前协议，定义资源路径  ******/\n    var protocol = window.location.protocol;\n    if (window.location.protocol == 'file:') {\n      //本地的，那就用http\n      protocol = 'http:';\n    }\n    if (this.resourcesUrl.indexOf('://') == -1) {\n      //还没设置过，进行设置\n      this.resourcesUrl = protocol + this.resourcesUrl;\n    }\n\n    //this.resourcesUrl = 'file://G:/git/translate';\n\n  },\n  /**\n   * 执行翻译操作\n   */\n  execute_v1: function () {\n    /*********** 判断translate 的id是否存在，不存在就创建一个  */\n    if (document.getElementById('translate') == null) {\n      if (translate.selectLanguageTag.show) {\n        var body_trans = document.getElementsByTagName('body')[0];\n        var div = document.createElement(\"div\");  //创建一个script标签\n        div.id = \"translate\";\n        body_trans.appendChild(div);\n      }\n    }\n\n    /* 处理1.0 - 1.1 升级的 */\n    if (translate.includedLanguages == '') {\n      //如果未设置，用默认的\n      translate.selectLanguageTag.languages = translate.includedLanguages;\n    }\n    /* 用户1.0版本设置过这个，那么就以这个为主 */\n    console.log('translate.js tip: translate.includedLanguages obsolete, please use the translate.selectLanguageTag.languages are set');\n\n\n    /****** 先加载资源  ******/\n    var head0 = document.getElementsByTagName('head')[0];\n    var script = document.createElement(\"script\");  //创建一个script标签\n    script.type = \"text/javascript\";\n    //script.async = true;\n    script.src = this.resourcesUrl + '/js/element.js';\n    head0.appendChild(script);\n  },\n\n  /**\n   * 设置Cookie，失效时间一年。\n   * @param name\n   * @param value\n   */\n  setCookie: function (name, value) {\n    var cookieString = name + \"=\" + escape(value);\n    document.cookie = cookieString;\n  },\n\n  //获取Cookie。若是不存再，返回空字符串\n  getCookie: function (name) {\n    var strCookie = document.cookie;\n    var arrCookie = strCookie.split(\"; \");\n    for (var i = 0; i < arrCookie.length; i++) {\n      var arr = arrCookie[i].split(\"=\");\n      if (arr[0] == name) {\n        return unescape(arr[1]);\n      }\n    }\n    return \"\";\n  },\n\n  /**\n   * 获取当前页面采用的是什么语言\n   * 返回值如 en、zh-CN、zh-TW （如果是第一次用，没有设置过，那么返回的是 translate.localLanguage 设置的值）\t\t\n   */\n  currentLanguage: function () {\n    //translate.check();\n    var cookieValue = translate.getCookie('googtrans');\n    if (cookieValue.length > 0) {\n      return cookieValue.substr(cookieValue.lastIndexOf('/') + 1, cookieValue.length - 1);\n    } else {\n      return translate.localLanguage;\n    }\n  },\n\n  /**\n   * 切换语言，比如切换为英语、法语\n     * @param languageName 要切换的语言语种。传入如 en、zh-CN\n   * \t\t\t\t会自动根据传入的语言来判断使用哪种版本。比如传入 en、zh-CN 等，则会使用v1.x版本\n   * \t\t\t\t\t\t\t\t\t\t\t\t\t\t传入 chinese_simplified 、english 等，则会使用 v2.x版本\n   */\n  changeLanguage: function (languageName) {\n    //判断使用的是否是v1.x\n    var v1 = ',en,de,hi,lt,hr,lv,ht,hu,zh-CN,hy,uk,mg,id,ur,mk,ml,mn,af,mr,uz,ms,el,mt,is,it,my,es,et,eu,ar,pt-PT,ja,ne,az,fa,ro,nl,en-GB,no,be,fi,ru,bg,fr,bs,sd,se,si,sk,sl,ga,sn,so,gd,ca,sq,sr,kk,st,km,kn,sv,ko,sw,gl,zh-TW,pt-BR,co,ta,gu,ky,cs,pa,te,tg,th,la,cy,pl,da,tr,';\n    if (v1.indexOf(',' + languageName + ',') > -1) {\n      //用的是v1.x\n      console.log('您使用的是v1版本的切换语种方式，v1已在2021年就以废弃，请更换为v2，参考文档： http://translate.zvo.cn/41549.html');\n      translate.check();\n\n      var googtrans = '/' + translate.localLanguage + '/' + languageName;\n\n      //先清空泛解析域名的设置\n      var s = document.location.host.split('.');\n      if (s.length > 2) {\n        var fanDomain = s[s.length - 2] + '.' + s[s.length - 1];\n        document.cookie = 'googtrans=;expires=' + (new Date(1)) + ';domain=' + fanDomain + ';path=/';\n        document.cookie = 'googtrans=' + googtrans + ';domain=' + fanDomain + ';path=/';\n      }\n\n      translate.setCookie('googtrans', '' + googtrans);\n      location.reload();\n      return;\n    }\n\n    //用的是v2.x或更高\n    translate.setUseVersion2();\n    //判断是否是第一次翻译，如果是，那就不用刷新页面了。 true则是需要刷新，不是第一次翻译\n    if (translate.to != null && translate.to.length > 0) {\n      //当前目标值有值，且目标语言跟当前语言不一致，那当前才是已经被翻译过的\n      if (translate.to != translate.language.getLocal()) {\n        var isReload = true; //标记要刷新页面\n      }\n    }\n\n\n    translate.to = languageName;\n    translate.storage.set('to', languageName);\t//设置目标翻译语言\n\n    if (isReload) {\n      location.reload(); //刷新页面\n    } else {\n      //不用刷新，直接翻译\n      translate.execute(); //翻译\n    }\n  },\n\n  /**\n   * 自检提示，适用于 v1.x， 在 v2.x中已废弃\n   */\n  check: function () {\n    if (window.location.protocol == 'file:') {\n      console.log('\\r\\n---WARNING----\\r\\ntranslate.js 主动翻译组件自检异常，当前协议是file协议，翻译组件要在正常的线上http、https协议下才能正常使用翻译功能\\r\\n------------');\n    }\n  },\n\n\n  /**************************** v2.0 */\n  to: '', //翻译为的目标语言，如 english 、chinese_simplified\n  //用户第一次打开网页时，自动判断当前用户所在国家使用的是哪种语言，来自动进行切换为用户所在国家的语种。\n  //如果使用后，第二次在用，那就优先以用户所选择的为主，这个就不管用了\n  //默认是false，不使用，可设置true：使用\n  //使用 setAutoDiscriminateLocalLanguage 进行设置\n  autoDiscriminateLocalLanguage: false,\n  documents: [], //指定要翻译的元素的集合,可设置多个，如设置： document.getElementsByTagName('DIV')\n  //翻译时忽略的一些东西，比如忽略某个tag、某个class等\n  ignore: {\n    tag: ['style', 'script', 'link', 'pre', 'code'],\n    class: ['ignore', 'translateSelectLanguage'],\n    id: [],\n    /*\n      传入一个元素，判断这个元素是否是被忽略的元素。 这个会找父类，看看父类中是否包含在忽略的之中。\n      return true是在忽略的之中，false不再忽略的之中\n    */\n    isIgnore: function (ele) {\n      if (ele == null || typeof (ele) == 'undefined') {\n        return false;\n      }\n\n      var parentNode = ele;\n      var maxnumber = 100;\t//最大循环次数，避免死循环\n      while (maxnumber-- > 0) {\n        if (parentNode == null || typeof (parentNode) == 'undefined') {\n          //没有父元素了\n          return false;\n        }\n\n        //判断Tag\n        //var tagName = parentNode.nodeName.toLowerCase(); //tag名字，小写\n        var nodename = translate.element.getNodeName(parentNode).toLowerCase(); //tag名字，小写\n        if (nodename.length > 0) {\n          //有nodename\n          if (nodename == 'body' || nodename == 'html' || nodename == '#document') {\n            //上层元素已经是顶级元素了，那肯定就不是了\n            return false;\n          }\n          if (translate.ignore.tag.indexOf(nodename) > -1) {\n            //发现ignore.tag 当前是处于被忽略的 tag\n            return true;\n          }\n        }\n\n\n        //判断class name\n        if (parentNode.className != null) {\n          var classNames = parentNode.className;\n          if (classNames == null || typeof (classNames) != 'string') {\n            continue;\n          }\n          //console.log('className:'+typeof(classNames));\n          //console.log(classNames);\n          classNames = classNames.trim().split(' ');\n          for (var c_index = 0; c_index < classNames.length; c_index++) {\n            if (classNames[c_index] != null && classNames[c_index].trim().length > 0) {\n              //有效的class name，进行判断\n              if (translate.ignore.class.indexOf(classNames[c_index]) > -1) {\n                //发现ignore.class 当前是处于被忽略的 class\n                return true;\n              }\n            }\n          }\n        }\n\n        //判断id\n        if (parentNode.id != null && typeof (parentNode.id) != 'undefined') {\n          //有效的class name，进行判断\n          if (translate.ignore.id.indexOf(parentNode.id) > -1) {\n            //发现ignore.id 当前是处于被忽略的 id\n            return true;\n          }\n        }\n\n        //赋予判断的元素向上一级\n        parentNode = parentNode.parentNode;\n      }\n\n      return false;\n    }\n  },\n  //自定义翻译术语\n  nomenclature: {\n    /*\n      术语表\n      一维：要转换的语种，如 english\n      二维：翻译至的目标语种，如 english\n      三维：要转换的字符串，如 \"你好\"\n      结果：自定义的翻译结果，如 “Hallo”\n    */\n    data: new Array(),\n\n    /*\n      原始术语表，可编辑的\n      一维：要自定义目标词\n      二维：针对的是哪个语种\n      值：要翻译为什么内容\n\n      其设置如 \n      var data = new Array();\n      data['版本'] = {\n        english : 'banben',\n        korean : 'BanBen'\n      };\n      data['国际化'] = {\n        english : 'guojihua',\n        korean : 'GuoJiHua'\n      };\n    \t\n      【已过时】\n    */\n    old_Data: [],\n    /*\n    set:function(data){\n      translate.nomenclature.data = data;\n    },\n    */\n    set: function (data) {\n      alert('请将 translate.nomenclature.set 更换为 append，具体使用可参考： https://github.com/xnx3/translate ');\n    },\n    /*\n      向当前术语库中追加自定义术语。如果追加的数据重复，会自动去重\n      传入参数：\n        from 要转换的语种\n        to 翻译至的目标语种\n        properties 属于配置表，格式如：\n            你好=Hello\n            世界=ShiJie\n\n    */\n    append: function (from, to, properties) {\n      if (typeof (translate.nomenclature.data[from]) == 'undefined') {\n        translate.nomenclature.data[from] = new Array();\n      }\n      if (typeof (translate.nomenclature.data[from][to]) == 'undefined') {\n        translate.nomenclature.data[from][to] = new Array();\n      }\n\n      //将properties进行分析\n      //按行拆分\n      var line = properties.split('\\n');\n      //console.log(line)\n      for (var line_index = 0; line_index < line.length; line_index++) {\n        var item = line[line_index].trim();\n        if (item.length < 1) {\n          //空行，忽略\n          continue;\n        }\n        var kvs = item.split('=');\n        //console.log(kvs)\n        if (kvs.length != 2) {\n          //不是key、value构成的，忽略\n          continue;\n        }\n        var key = kvs[0].trim();\n        var value = kvs[1].trim();\n        //console.log(key)\n        if (key.length == 0 || value.length == 0) {\n          //其中某个有空，则忽略\n          continue;\n        }\n\n\n        //加入，如果之前有加入，则会覆盖\n        translate.nomenclature.data[from][to][key] = value;\n        //console.log(local+', '+target+', key:'+key+', value:'+value);\n      }\n\n      //追加完后，对整个对象数组进行排序，key越大越在前面\n      translate.nomenclature.data[from][to] = translate.util.objSort(translate.nomenclature.data[from][to]);\n\n    },\n    //获取当前定义的术语表\n    get: function () {\n      return translate.nomenclature.data;\n    },\n    //对传入的str字符进行替换，将其中的自定义术语提前进行替换，然后将替换后的结果返回\n    dispose: function (str) {\n      if (str == null || str.length == 0) {\n        return str;\n      }\n      //if(translate.nomenclature.data.length == 0){\n      //\treturn str;\n      //}\n      //判断当前翻译的两种语种是否有自定义术语库\n      //console.log(typeof(translate.nomenclature.data[translate.language.getLocal()][translate.to]))\n      if (typeof (translate.nomenclature.data[translate.language.getLocal()]) == 'undefined' || typeof (translate.nomenclature.data[translate.language.getLocal()][translate.to]) == 'undefined') {\n        return str;\n      }\n      //console.log(str)\n      for (var originalText in translate.nomenclature.data[translate.language.getLocal()][translate.to]) {\n        var translateText = translate.nomenclature.data[translate.language.getLocal()][translate.to][originalText];\n        if (typeof (translateText) == 'function') {\n          //进行异常的预处理调出\n          continue;\n        }\n\n        var index = str.indexOf(originalText);\n        if (index > -1) {\n          //console.log('find -- '+originalText+', \\t'+translateText);\n          if (translate.language.getLocal() == 'english') {\n            //如果本地语种是英文，那么还要判断它的前后，避免比如要替换 is 将 display 中的is给替换，将单词给强行拆分了\n\n            //判断这个词前面是否符合\n            var beforeChar = '';\t//前面的字符\n            if (index == 0) {\n              //前面没别的字符了，那前面合适\n            } else {\n              //前面有别的字符,判断是什么字符，如果是英文，那么这个是不能被拆分的，要忽略\n              beforeChar = str.substr(index - 1, 1);\n              //console.log('beforeChar:'+beforeChar+', str:'+str)\n              var lang = translate.language.getCharLanguage(beforeChar);\n              //console.log(lang);\n              if (lang == 'english') {\n                //调出，不能强拆\n                continue;\n              }\n            }\n\n            //判断这个词的后面是否符合\n            var afterChar = ''; //后面的字符\n            if (index + originalText.length == str.length) {\n              //后面没别的字符了，那前面合适\n              //console.log(originalText+'， meile '+str)\n            } else {\n              //后面有别的字符,判断是什么字符，如果是英文，那么这个是不能被拆分的，要忽略\n              afterChar = str.substr(index + originalText.length, 1);\n              var lang = translate.language.getCharLanguage(afterChar);\n              if (lang == 'english') {\n                //跳出，不能强拆\n                continue;\n              }\n            }\n\n            str = str.replace(new RegExp(beforeChar + originalText + afterChar, 'g'), beforeChar + translateText + afterChar);\n          } else {\n            //其他情况，如汉语、汉语等语种\n            str = str.replace(new RegExp(originalText, 'g'), translateText);\n          }\n\n        }\n      }\n\n      return str;\n\n      /*\n      //遍历一维\n      for(var originalText in translate.nomenclature.data){\n        var languageResult = translate.nomenclature.data[originalText];\n        if(typeof(languageResult) == 'function'){\n          //进行异常的预处理调出\n          continue;\n        }\n\n        if(typeof(languageResult[translate.to]) == 'undefined'){\n          //console.log('und');\n          continue;\n        }\n\n        //var hash = translate.util.hash(originalText);\n\n        //console.log(originalText+',\\t'+str);\n        if(str.indexOf(originalText) > -1){\n          //console.log('find -- '+originalText+', \\t'+languageResult[translate.to]);\n          str = str.replace(new RegExp(originalText,'g'),languageResult[translate.to]);\n        }\n      }\n    \t\n    \t\n      return str;\n      */\n    },\n\n  },\n  office: {\n    /*\n      网页上翻译之后，自动导出当前页面的术语库\n    \t\n      需要先指定本地语种，会自动将本地语种进行配置术语库\n    \t\n    */\n    export: function () {\n      if (translate.language.getLocal() == translate.language.getCurrent()) {\n        alert('本地语种跟要翻译的语种一致，无需导出');\n        return;\n      }\n\n      var text = '';\n      for (var uuid in translate.nodeQueue) {\n        var queueValue = translate.nodeQueue[uuid];\n        for (var lang in translate.nodeQueue[uuid].list) {\n          //console.log('------'+lang)\n          if (typeof (lang) != 'string' || lang.length < 1) {\n            continue;\n          }\n          //if(translate.language.getLocal() == lang){\n          //console.log(translate.nodeQueue[uuid].list[lang]);\n          for (var hash in translate.nodeQueue[uuid].list[lang]) {\n            //console.log(translate.nodeQueue[uuid].list[lang][hash].original);\n            //console.log(translate.nodeQueue[uuid].list[lang][hash].original);\n            text = text + '\\n' + translate.nodeQueue[uuid].list[lang][hash].original + '=' + translate.storage.get('hash_' + translate.language.getCurrent() + '_' + hash);\n\n          }\n          //}\n        }\n\n      }\n\n      if (text.length > 0) {\n        //有内容\n        text = 'translate.office.append(\\'' + translate.language.getCurrent() + '\\',`' + text + '\\n`);';\n        //console.log(text);\n        translate.util.loadMsgJs();\n        msg.popups({\n          text: '<textarea id=\"msgPopupsTextarea\" style=\"width:100%; height:100%;\">loaing...</textarea>',\n          width: '750px',\n          height: '600px',\n          padding: '1px',\n        });\n        document.getElementById('msgPopupsTextarea').value = text;\n      } else {\n        msg.alert('无有效内容');\n      }\n\n\n    },\n    //显示导出面板\n    showPanel: function () {\n      let panel = document.createElement('div');\n      panel.setAttribute('id', 'translate_export');\n      panel.setAttribute('class', 'ignore');\n\n      //导出按钮\n      let button = document.createElement('button');\n      button.onclick = function () {\n        translate.office.export();\n      };\n      button.innerHTML = '导出配置信息';\n      button.setAttribute('style', 'margin-left: 72px; margin-top: 30px; margin-bottom: 20px; font-size: 25px;');\n      panel.appendChild(button);\n\n      //说明文字\n      let textdiv = document.createElement('div');\n      textdiv.innerHTML = '1. 首先将当前语种切换为你要翻译的语种<br/>2. 点击导出按钮，将翻译的配置信息导出<br/>3. 将导出的配置信息粘贴到代码中，即可完成<br/><a href=\"asd\" target=\"_black\" style=\"color: aliceblue;\">点此进行查阅详细使用说明</a>';\n      textdiv.setAttribute('style', 'font-size: 14px; padding: 12px;');\n\n      panel.appendChild(textdiv);\n\n      panel.setAttribute('style', 'background-color: black; color: #fff; width: 320px; height: 200px; position: fixed; bottom: 50px; right: 50px;');\n      //把元素节点添加到body元素节点中成为其子节点，放在body的现有子节点的最后\n      document.body.appendChild(panel);\n\n      translate.util.loadMsgJs();\n    },\n    /*\n      追加离线翻译数据。如果追加的数据重复，会自动去重\n      传入参数：\n        from 要转换的语种\n        to 翻译至的目标语种\n        properties 属于配置表，格式如：\n            你好=Hello\n            世界=ShiJie\n      这个传入参数跟 translate.nomenclature.append 的传入参数格式是一致的\t\t\t\n    */\n    append: function (to, properties) {\n      //console.log(properties)\n      //将properties进行分析\n      //按行拆分\n      var line = properties.split('\\n');\n      //console.log(line)\n      for (var line_index = 0; line_index < line.length; line_index++) {\n        var item = line[line_index].trim();\n        if (item.length < 1) {\n          //空行，忽略\n          continue;\n        }\n        var kvs = item.split('=');\n        //console.log(kvs)\n        if (kvs.length != 2) {\n          //不是key、value构成的，忽略\n          continue;\n        }\n        var key = kvs[0];\n        var value = kvs[1];\n        //console.log(key)\n        if (key.length == 0 || value.length == 0) {\n          //其中某个有空，则忽略\n          continue;\n        }\n        //console.log('set---'+key);\n        //加入 storate\n        translate.storage.set('hash_' + to + '_' + translate.util.hash(key), value);\n      }\n    },\n  },\n  setAutoDiscriminateLocalLanguage: function () {\n    translate.autoDiscriminateLocalLanguage = true;\n  },\n  /*\n    待翻译的页面的node队列\n    一维：key:uuid，也就是execute每次执行都会创建一个翻译队列，这个是翻译队列的唯一标识。   \n       value:\n        k/v \n    二维：对象形态，具体有：\n       key:expireTime 当前一维数组key的过期时间，到达过期时间会自动删除掉这个一维数组。如果<0则代表永不删除，常驻内存\n       value:list 待翻译的页面的node队列\n    三维：针对二维的value，  key:english、chinese_simplified等语种，这里的key便是对value的判断，取value中的要翻译的词是什么语种，对其进行了语种分类    value: k/v\n    四维：针对三维的value，  key:要翻译的词（经过语种分割的）的hash，   value: node数组\n    五维：针对四维的value，  这是个对象， 其中\n        original: 是三维的key的hash的原始文字，也就是 node 中的原始文字。\n        cacheHash: 如果翻译时匹配到了自定义术语库中的词，那么翻译完后存入到缓存中时，其缓存的翻译前字符串已经不是original，二是匹配完术语库后的文本的hash了。所以这里额外多增加了这个属性。如果匹配了术语库，那这里就是要进行缓存的翻译前文本的hash，如果未使用术语库，这里就跟其key-hash 相同。\n        translateText: 针对 original 的经过加工过的文字，比如经过自定义术语操作后的，待翻译的文字。\n        nodes: 有哪些node元素中包含了这个词，都会在这里记录\n        beforeText: node元素中进行翻译结果赋予时，额外在翻译结果的前面加上的字符串。其应用场景为，如果中英文混合场景下，避免中文跟英文挨着导致翻译为英语后，连到一块了。默认是空字符串 ''\n        afterText:  node元素中进行翻译结果赋予时，额外在翻译结果的后面加上的字符串。其应用场景为，如果中英文混合场景下，避免中文跟英文挨着导致翻译为英语后，连到一块了。默认是空字符串 ''\n    六维：针对五维的 nodes，将各个具体的 node 以及 其操作的 attribute 以数组形式列出\n    七维：针对六维列出的nodes数组，其中包含：\n        node: 具体操作的node元素\n        attribute: 也就是翻译文本针对的是什么，是node本身（nodeValue），还是 node 的某个属性，比如title属性，这则是设置为 \"title\"。如果这里不为空，那就是针对的属性操作的。 如果这里为空或者undefined ，那就是针对node本身，也就是 nodeValue 的字符串操作的\n  \t\n    生命周期： 当execute()执行时创建，  当execute结束（其中的所有request接收到响应并渲染完毕）时销毁（当前暂时不销毁，以方便调试）\n  */\n  nodeQueue: {},\n  //指定要翻译的元素的集合,可传入一个元素或多个元素\n  //如设置一个元素，可传入如： document.getElementsById('test')\n  //如设置多个元素，可传入如： document.getElementsByTagName('DIV')\n  setDocuments: function (documents) {\n    if (documents == null || typeof (documents) == 'undefined') {\n      return;\n    }\n\n    if (typeof (documents.length) == 'undefined') {\n      //不是数组，是单个元素\n      translate.documents[0] = documents;\n    } else {\n      //是数组，直接赋予\n      translate.documents = documents;\n    }\n    //清空翻译队列，下次翻译时重新检索\n    translate.nodeQueue = {};\n    console.log('set documents , clear translate.nodeQueue');\n  },\n  //获取当前指定翻译的元素（数组形式 [document,document,...]）\n  //如果用户未使用setDocuments 指定的，那么返回整个网页\n  getDocuments: function () {\n    if (translate.documents != null && typeof (translate.documents) != 'undefined' && translate.documents.length > 0) {\n      // setDocuments 指定的\n      return translate.documents;\n    } else {\n      //未使用 setDocuments指定，那就是整个网页了\n      return document.all; //翻译所有的\n    }\n  },\n  listener: {\n    //当前页面打开后，是否已经执行完execute() 方法进行翻译了，只要执行完一次，这里便是true。 （多种语言的API请求完毕并已渲染html）\n    isExecuteFinish: false,\n    //是否已经使用了 translate.listener.start() 了，如果使用了，那这里为true，多次调用 translate.listener.start() 只有第一次有效\n    isStart: false,\n    //translate.listener.start();\t//开启html页面变化的监控，对变化部分会进行自动翻译。注意，这里变化区域，是指使用 translate.setDocuments(...) 设置的区域。如果未设置，那么为监控整个网页的变化\n    start: function () {\n\n      translate.temp_linstenerStartInterval = setInterval(function () {\n        if (document.readyState == 'complete') {\n          //dom加载完成，进行启动\n          clearInterval(translate.temp_linstenerStartInterval);//停止\n          translate.listener.addListener();\n        }\n\n        //if(translate.listener.isExecuteFinish){ //执行完过一次，那才能使用\n        /*if(translate.listener.isStart){\n          //已开启了\n          return;\n        }*/\n\n        //console.log('translate.temp_linstenerStartInterval Finish!');\n        //}\n      }, 50);\n\n\n      //\twindow.onload = function(){\n      /* if(translate.listener.isStart){\n        //已开启了\n        return;\n      } */\n\n      //判断是否是执行完一次了\n      //        translate.temp_linstenerStartInterval = setInterval(function(){\n      //if(translate.listener.isExecuteFinish){ //执行完过一次，那才能使用\n      /*if(translate.listener.isStart){\n        //已开启了\n        return;\n      }*/\n      //\t\t\t\tclearInterval(translate.temp_linstenerStartInterval);//停止\n      //\t\t\t\ttranslate.listener.addListener();\n      //console.log('translate.temp_linstenerStartInterval Finish!');\n      //}\n      //\t      }, 50);\n      //\t}\n\n\n    },\n    //增加监听，开始监听。这个不要直接调用，需要使用上面的 start() 开启\n    addListener: function () {\n      translate.listener.isStart = true; //记录已执行过启动方法了\n\n      // 观察器的配置（需要观察什么变动）\n      const config = { attributes: true, childList: true, subtree: true };\n      // 当观察到变动时执行的回调函数\n      const callback = function (mutationsList, observer) {\n        var documents = []; //有变动的元素\n\n        // Use traditional 'for loops' for IE 11\n        for (let mutation of mutationsList) {\n          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n            //多了个组件\n            documents.push.apply(documents, mutation.addedNodes);\n            //    console.log(mutation.addedNodes);\n            //}else if (mutation.type === 'attributes') {\n            //   console.log('The ' + mutation.attributeName + ' attribute was modified.');\n          }\n        }\n\n        //console.log(documents);\n        if (documents.length > 0) {\n          //有变动，需要看看是否需要翻译\n          translate.execute(documents); //指定要翻译的元素的集合,可传入一个或多个元素。如果不设置，默认翻译整个网页\n        }\n      };\n      // 创建一个观察器实例并传入回调函数\n      const observer = new MutationObserver(callback);\n      // 以上述配置开始观察目标节点\n      var docs = translate.getDocuments();\n      for (var docs_index = 0; docs_index < docs.length; docs_index++) {\n        var doc = docs[docs_index];\n        if (doc != null) {\n          observer.observe(doc, config);\n        }\n      }\n    },\n    /*\n      每当执行完一次渲染任务（翻译）时会触发此。注意页面一次翻译会触发多个渲染任务。普通情况下，一次页面的翻译可能会触发两三次渲染任务。\n      另外如果页面中有ajax交互方面的信息，时，每次ajax信息刷新后，也会进行翻译，也是一次渲染任务。\n      这个是为了方便扩展使用。比如在layui中扩展，监控 select 的渲染\n    */\n    renderTaskFinish: function (renderTask) {\n      //console.log(renderTask);\n    }\n  },\n  //对翻译结果进行替换渲染的任务，将待翻译内容替换为翻译内容的过程\n  renderTask: class {\n    constructor() {\n      /*\n       * 任务列表\n       * 一维数组 [hash] = tasks;  tasks 是多个task的数组集合\n       * 二维数组 [task,task,...]，存放多个 task，每个task是一个替换。这里的数组是同一个nodeValue的多个task替换\n       * 三维数组 task['originalText'] 、 task['resultText'] 存放要替换的字符串\n               task['attribute'] 存放要替换的属性，比如 a标签的title属性。 如果是直接替换node.nodeValue ，那这个没有\n       */\n      this.taskQueue = [];\n\n      /*\n       * 要进行翻译的node元素，\n       * 一维数组 key:node.nodeValue 的 hash ， value:node的元素数组\n       * 二维数组，也就是value中包含的node集合 [node,node,...]\n         */\n      this.nodes = [];\n    }\n\n    /**\n     * 向替换队列中增加替换任务\n     * node:要替换的字符属于那个node元素\n     * originalText:待翻译的字符\n     * resultText:翻译后的结果字符\n     * attribute: 要替换的是哪个属性，比如 a标签的title属性，这里便是传入title。如果不是替换属性，这里不用传入，或者传入null\n     */\n    add(node, originalText, resultText, attribute) {\n      var nodeAnaly = translate.element.nodeAnalyse.get(node, attribute); //node解析\n      //var hash = translate.util.hash(translate.element.getTextByNode(node)); \t//node中内容的hash\n      var hash = translate.util.hash(nodeAnaly['text']);\n      //console.log('--------------'+hash);\n      //console.log(nodeAnaly);\n      //console.log(node);\n      //console.log('originalText:'+originalText+', resultText:'+resultText+', attribute:'+attribute);\n      /****** 加入翻译的元素队列  */\n      if (typeof (this.nodes[hash]) == 'undefined') {\n        this.nodes[hash] = new Array();\n      }\n      this.nodes[hash].push(node);\n      //console.log(node)\n\n      /****** 加入翻译的任务队列  */\n      var tasks = this.taskQueue[hash];\n      if (tasks == null || typeof (tasks) == 'undefined') {\n        //console.log(node.nodeValue);\n        tasks = new Array(); //任务列表，存放多个 task，每个task是一个替换。这里的数组是同一个nodeValue的多个task替换\n      }\n      var task = new Array();\n\n      //v2.3.3 增加 -- 开始\n      //这里要进行处理，因为有时候翻译前，它前或者后是有空格的，但是翻译后会把前或者后的空格给自动弄没了，如果是这种情况，要手动补上\n      if (originalText.substr(0, 1) == ' ') {\n        //console.log('第一个字符是空格');\n        if (resultText.substr(0, 1) != ' ') {\n          //翻译结果的第一个字符不是空格，那么补上\n          resultText = ' ' + resultText;\n        }\n      }\n      if (originalText.substr(originalText.length - 1, 1) === ' ') {\n        //console.log('最后一个字符是空格');\n        if (resultText.substr(0, 1) != ' ') {\n          //翻译结果的最后一个字符不是空格，那么补上\n          resultText = resultText + ' ';\n        }\n      }\n      //v2.3.3 增加 -- 结束\n\n      task['originalText'] = originalText;\n      task['resultText'] = resultText;\n      task['attribute'] = attribute;\n\n      //console.log(task);\n      tasks.push(task);\n      this.taskQueue[hash] = tasks;\n      /****** 加入翻译的任务队列 end  */\n    }\n    //进行替换渲染任务，对页面进行渲染替换翻译\n    execute() {\n      //先对tasks任务队列的替换词进行排序，将同一个node的替换词有大到小排列，避免先替换了小的，大的替换时找不到\n      for (var hash in this.taskQueue) {\n        var tasks = this.taskQueue[hash];\n        if (typeof (tasks) == 'function') {\n          //进行异常的预处理调出\n          continue;\n        }\n\n        //进行排序,将原字符串长的放前面，避免造成有部分不翻译的情况（bug是先翻译了短的，导致长的被打断而无法进行适配）\n        tasks.sort((a, b) => b.originalText.length - a.originalText.length);\n\n        this.taskQueue[hash] = tasks;\n      }\n\n      //console.log('===========task=========');\n      //console.log(this.taskQueue);\n      //console.log(this.nodes);\n      //console.log('===========task======end===');\n\n      //对nodeQueue进行翻译\n      for (var hash in this.nodes) {\n        var tasks = this.taskQueue[hash]; //取出当前node元素对应的替换任务\n        //var tagName = this.nodes[hash][0].nodeName; //以下节点的tag name\n        //console.log(tasks);\n        for (var node_index = 0; node_index < this.nodes[hash].length; node_index++) {\n          //对这个node元素进行替换翻译字符\n          for (var task_index = 0; task_index < tasks.length; task_index++) {\n            var task = tasks[task_index];\n            if (typeof (tasks) == 'function') {\n              //进行异常的预处理调出\n              continue;\n            }\n\n            //console.log(this.nodes[hash][task_index]);\n            translate.element.nodeAnalyse.set(this.nodes[hash][task_index], task.originalText, task.resultText, task['attribute']);\n            /*\n            //var tagName = translate.element.getTagNameByNode(this.nodes[hash][task_index]);//节点的tag name\n            //console.log(tagName)\n            //console.log(this.nodes[hash][task_index])\n            //var tagName = this.nodes[hash][task_index].nodeName; //节点的tag name\n            var nodename = translate.element.getNodeName(this.nodes[hash][task_index]);\n          \t\n            //console.log(this.nodes[hash][task_index]+', '+task.originalText+', '+task.resultText+', tagName:'+tagName);\n            if(nodename == 'META'){\n              if(typeof(this.nodes[hash][task_index].name) != 'undefined' && this.nodes[hash][task_index].name != null){\n                //var nodeName = this.nodes[hash][task_index].name.toLowerCase();  //取meta 标签的name 属性\n              \t\n                this.nodes[hash][task_index].content = this.nodes[hash][task_index].content.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n              }\n            }else if(nodename == 'IMG'){\n              this.nodes[hash][task_index].alt = this.nodes[hash][task_index].alt.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            }else{\n              //普通的\n              //console.log('task.originalText : '+task.originalText);\n              //console.log(translate.util.regExp.pattern(task.originalText))\n              //console.log('task.resultText : '+task.resultText);\n              this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            }\n            */\n          }\n        }\n      }\n\n      //监听\n      if (typeof (this.taskQueue) != 'undefined' && this.taskQueue.length > 0) {\n        translate.listener.renderTaskFinish(this);\n      }\n    }\n  },\n\n  //执行翻译操作。翻译的是 nodeQueue 中的\n  //docs 如果传入，那么翻译的只是传入的这个docs的。传入如 [document.getElementById('xxx'),document.getElementById('xxx'),...]\n  execute: function (docs) {\n    if (typeof (doc) != 'undefined') {\n      //execute传入参数，只有v2版本才支持\n      translate.useVersion = 'v2';\n    }\n\n    if (translate.useVersion == 'v1') {\n      //if(this.to == null || this.to == ''){\n      //采用1.x版本的翻译，使用google翻译\n      //translate.execute_v1();\n      //return;\n      //v2.5.1增加\n      console.log('提示：https://github.com/xnx3/translate 在 v2.5 版本之后，由于谷歌翻译调整，免费翻译通道不再支持，所以v1版本的翻译接口不再被支持，v1全线下架。考虑到v1已不能使用，当前已自动切换到v2版本。如果您使用中发现什么异常，请针对v2版本进行适配。');\n      translate.useVersion = 'v2';\n    }\n\n    /****** 采用 2.x 版本的翻译，使用自有翻译算法 */\n\n\n    //每次执行execute，都会生成一个唯一uuid，也可以叫做队列的唯一标识，每一次执行execute都会创建一个独立的翻译执行队列\n    var uuid = translate.util.uuid();\n    //console.log('=====')\n    //console.log(translate.nodeQueue);\n\n    /* v2.4.3 将初始化放到了 translate.element.whileNodes 中，如果uuid对应的没有，则自动创建\n\n    translate.nodeQueue[uuid] = new Array(); //创建\n    translate.nodeQueue[uuid]['expireTime'] = Date.now() + 120*1000; //删除时间，10分钟后删除\n    translate.nodeQueue[uuid]['list'] = new Array(); \n    */\n    //console.log(translate.nodeQueue);\n    //console.log('=====end')\n\n    //如果页面打开第一次使用，先判断缓存中有没有上次使用的语种，从缓存中取出\n    if (translate.to == null || translate.to == '') {\n      var to_storage = translate.storage.get('to');\n      if (to_storage != null && typeof (to_storage) != 'undefined' && to_storage.length > 0) {\n        translate.to = to_storage;\n      }\n    }\n\n    //渲染select选择语言\n    try {\n      translate.selectLanguageTag.render();\n    } catch (e) {\n      console.log(e);\n    }\n\n    //判断是否还未指定翻译的目标语言\n    if (translate.to == null || typeof (translate.to) == 'undefined' || translate.to.length == 0) {\n      //未指定，判断如果指定了自动获取用户本国语种了，那么进行获取\n      if (translate.autoDiscriminateLocalLanguage) {\n        translate.executeByLocalLanguage();\n      }\n\n      //没有指定翻译目标语言、又没自动获取用户本国语种，则不翻译\n      return;\n    }\n\n    //判断本地语种跟要翻译的目标语种是否一样，如果是一样，那就不需要进行任何翻译\n    if (translate.to == translate.language.getLocal()) {\n      return;\n    }\n\n    /********** 翻译进行 */\n\n    //先进行图片的翻译替换，毕竟图片还有加载的过程\n    translate.images.execute();\n\n    /*\n      进行翻译指定的node操作。优先级为：\n      1. 这个方法已经指定的翻译 nodes\n      2. setDocuments 指定的 \n      3. 整个网页 \n      其实2、3都是通过 getDocuments() 取，在getDocuments() 就对2、3进行了判断\n    */\n    var all;\n    if (typeof (docs) != 'undefined') {\n      //1. 这个方法已经指定的翻译 nodes\n\n      if (docs == null) {\n        //要翻译的目标区域不存在\n        console.log('translate.execute(...) 中传入的要翻译的目标区域不存在。');\n        return;\n      }\n\n      if (typeof (docs.length) == 'undefined') {\n        //不是数组，是单个元素\n        all = new Array();\n        all[0] = docs;\n      } else {\n        //是数组，直接赋予\n        all = docs;\n      }\n\n    } else {\n      //2、3\n      all = translate.getDocuments();\n    }\n    //console.log('----要翻译的目标元素-----');\n    //console.log(all)\n\n    //检索目标内的node元素\n    for (var i = 0; i < all.length & i < 20; i++) {\n      var node = all[i];\n      translate.element.whileNodes(uuid, node);\n    }\n\n    //console.log('-----待翻译：----');\n    //console.log(translate.nodeQueue);\n\n    //translateTextArray[lang][0]\n    var translateTextArray = {};\t//要翻译的文本的数组，格式如 [\"你好\",\"欢迎\"]\n    var translateHashArray = {};\t//要翻译的文本的hash,跟上面的index是一致的，只不过上面是存要翻译的文本，这个存hash值\n\n    for (var lang in translate.nodeQueue[uuid]['list']) { //二维数组中，取语言\n      //console.log('lang:'+lang); //lang为english这种语言标识\n      if (lang == null || typeof (lang) == 'undefined' || lang.length == 0 || lang == 'undefined') {\n        //console.log('lang is null : '+lang);\n        continue;\n      }\n\n      translateTextArray[lang] = [];\n      translateHashArray[lang] = [];\n\n      let task = new translate.renderTask();\n      //console.log(translate.nodeQueue);\n      //二维数组，取hash、value\n      for (var hash in translate.nodeQueue[uuid]['list'][lang]) {\n        if (typeof (translate.nodeQueue[uuid]['list'][lang][hash]) == 'function') {\n          //跳出，增加容错率。  正常情况下应该不会这样\n          continue;\n        }\n\n        //取原始的词，还未经过翻译的，需要进行翻译的词\n        //var originalWord = translate.nodeQueue[uuid]['list'][lang][hash]['original'];\t\n\n        //原始的node中的词\n        var originalWord = translate.nodeQueue[uuid]['list'][lang][hash]['original'];\n        //要翻译的词\n        var translateText = translate.nodeQueue[uuid]['list'][lang][hash]['translateText'];\n\n        /*\n                //自定义术语后的。如果\n                var nomenclatureOriginalWord = translate.nomenclature.dispose(cache);\n                if(nomenclatureOriginalWord != originalWord){\n                  has\n                }\n        */\n        //console.log(originalWord == translateText ? '1':'xin：'+translateText);\n        //根据hash，判断本地是否有缓存了\n        var cacheHash = originalWord == translateText ? hash : translate.util.hash(translateText); //如果匹配到了自定义术语库，那翻译前的hash是被改变了\n        translate.nodeQueue[uuid]['list'][lang][hash]['cacheHash'] = cacheHash; //缓存的hash。 缓存时，其hash跟翻译的语言是完全对应的，缓存的hash就是翻译的语言转换来的\n        var cache = translate.storage.get('hash_' + translate.to + '_' + cacheHash);\n        //console.log(key+', '+cache);\n        if (cache != null && cache.length > 0) {\n          //有缓存了\n          //console.log('find cache：'+cache);\n          //console.log(this.nodeQueue[lang][hash]['nodes']);\n          //直接将缓存赋予\n          //for(var index = 0; index < this.nodeQueue[lang][hash].length; index++){\n          //this.nodeQueue[lang][hash][index].nodeValue = cache;\n\n          for (var node_index = 0; node_index < translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length; node_index++) {\n            //this.nodeQueue[lang][hash]['nodes'][node_index].nodeValue = cache;\n            //console.log(originalWord);\n            task.add(translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['node'], originalWord, translate.nodeQueue[uuid]['list'][lang][hash]['beforeText'] + cache + translate.nodeQueue[uuid]['list'][lang][hash]['afterText'], translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['attribute']);\n            //this.nodeQueue[lang][hash]['nodes'][node_index].nodeValue = this.nodeQueue[lang][hash]['nodes'][node_index].nodeValue.replace(new RegExp(originalWord,'g'), cache);\n          }\n          //}\n\n          continue;\t//跳出，不用在传入下面的翻译接口了\n        }\n\n        /*\n        //取出数组\n        var queueNodes = this.nodeQueue[lang][hash];\n        if(queueNodes.length > 0){\n          //因为在这个数组中的值都是一样的，那么只需要取出第一个就行了\n          var valueStr = queueNodes[0].nodeValue;\n          valueStr = this.util.charReplace(valueStr);\n\n          translateTextArray[lang].push(valueStr);\n          translateHashArray[lang].push(hash);\n        }\n        */\n\n        //加入待翻译数组\n        translateTextArray[lang].push(translateText);\n        translateHashArray[lang].push(hash); //这里存入的依旧还是用原始hash，未使用自定义术语库前的hash，目的是不破坏 nodeQueue 的 key\n      }\n      task.execute(); //执行渲染任务\n    }\n\n    //window.translateHashArray = translateHashArray;\n\n    //统计出要翻译哪些语种 ，这里面的语种会调用接口进行翻译。其内格式如 english\n    var fanyiLangs = [];\n    for (var lang in translate.nodeQueue[uuid]['list']) { //二维数组中取语言\n      if (translateTextArray[lang].length < 1) {\n        continue;\n      }\n      fanyiLangs.push(lang);\n    }\n\n    /******* 用以记录当前是否进行完第一次翻译了 *******/\n    if (!translate.listener.isExecuteFinish) {\n      translate.temp_executeFinishNumber = 0;\t//下面请求接口渲染，翻译执行完成的次数\t\n      //判断是否是执行完一次了\n      translate.temp_executeFinishInterval = setInterval(function () {\n        if (translate.temp_executeFinishNumber == fanyiLangs.length) {\n          translate.listener.isExecuteFinish = true; //记录当前已执行完第一次了\n          clearInterval(translate.temp_executeFinishInterval);//停止\n          //console.log('translate.execute() Finish!');\n        }\n      }, 50);\n    }\n\n    if (fanyiLangs.length == 0) {\n      //没有需要翻译的，直接退出\n      return;\n    }\n\n    //进行掉接口翻译\n    for (var lang_index in fanyiLangs) { //一维数组，取语言\n      var lang = fanyiLangs[lang_index];\n      //console.log(typeof(translateTextArray[lang]))\n\n      if (typeof (translateTextArray[lang]) == 'undefined' || translateTextArray[lang].length < 1) {\n        return;\n      }\n\n      //自定义术语\n      /*var nomenclatureCache = translate.nomenclature.dispose(cache);\n      for(var ttr_index = 0; ttr_index<translateTextArray[lang].length; ttr_index++){\n        console.log(translateTextArray[lang][ttr_index])\n      }*/\n\n      /*** 翻译开始 ***/\n      var url = translate.request.api.host + translate.request.api.translate + '?v=' + translate.version;\n      var data = {\n        from: lang,\n        to: translate.to,\n        //text:JSON.stringify(translateTextArray[lang])\n        text: encodeURIComponent(JSON.stringify(translateTextArray[lang]))\n      };\n      translate.request.post(url, data, function (data) {\n        //console.log(data); \n        if (data.result == 0) {\n          console.log('=======ERROR START=======');\n          console.log(translateTextArray[data.from]);\n          //console.log(encodeURIComponent(JSON.stringify(translateTextArray[data.from])));\n\n          console.log('response : ' + data.info);\n          console.log('=======ERROR END  =======');\n          translate.temp_executeFinishNumber++; //记录执行完的次数\n          return;\n        }\n\n        //console.log('-----待翻译3：----');\n        //console.log(translate.nodeQueue);\n\n        //console.log('response:'+uuid);\n        let task = new translate.renderTask();\n        //遍历 translateHashArray\n        for (var i = 0; i < translateHashArray[data.from].length; i++) {\n          //翻译前的语种，如 english\n          var lang = data.from;\n          //翻译后的内容\n          var text = data.text[i];\n          //翻译前的hash对应下标\n          var hash = translateHashArray[data.from][i];\n          var cacheHash = translate.nodeQueue[uuid]['list'][lang][hash]['cacheHash'];\n\n\n\n          //取原始的词，还未经过翻译的，需要进行翻译的词\n          var originalWord = '';\n          try {\n            originalWord = translate.nodeQueue[uuid]['list'][lang][hash]['original'];\n            //console.log('bef:'+translate.nodeQueue[uuid]['list'][lang][hash]['beforeText']);\n          } catch (e) {\n            console.log('uuid:' + uuid + ', originalWord:' + originalWord + ', lang:' + lang + ', hash:' + hash + ', text:' + text + ', queue:' + translate.nodeQueue[uuid]);\n            console.log(e);\n            continue;\n          }\n\n          //for(var index = 0; index < translate.nodeQueue[lang][hash].length; index++){\n          for (var node_index = 0; node_index < translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length; node_index++) {\n            //translate.nodeQueue[lang][hash]['nodes'][node_index].nodeValue = translate.nodeQueue[lang][hash]['nodes'][node_index].nodeValue.replace(new RegExp(originalWord,'g'), text);\n            //加入任务\n            task.add(translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['node'], originalWord, translate.nodeQueue[uuid]['list'][lang][hash]['beforeText'] + text + translate.nodeQueue[uuid]['list'][lang][hash]['afterText'], translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['attribute']);\n          }\n          //}\n          /*\n          for(var index = 0; index < translate.nodeQueue[data.from][hash].length; index++){\n            translate.nodeQueue[data.from][hash][index].nodeValue = text;\n          }\n          */\n\n          //将翻译结果以 key：hash  value翻译结果的形式缓存\n          translate.storage.set('hash_' + data.to + '_' + cacheHash, text);\n        }\n        task.execute(); //执行渲染任务\n        translate.temp_executeFinishNumber++; //记录执行完的次数\n\n      });\n      /*** 翻译end ***/\n\n\n    }\n  },\n  element: {\n    //对翻译前后的node元素的分析（翻以前）及渲染（翻译后）\n    nodeAnalyse: {\n      /*\n        获取node中的要进行翻译的文本内容、以及要操作的实际node对象（这个node对象很可能是传入的node中的某个子node）\n        node \n        attribute 要获取的是某个属性的值，还是node本身的值。比如 a标签的title属性的值，则传入 title。  如果是直接获取node.nodeValue ，那这个没有\n\n        返回结果是一个数组。其中：\n          ['text']:要进行翻译的text内容文本\n          ['node']:要进行翻译的目标node\n\n      */\n      get: function (node, attribute) {\n        return translate.element.nodeAnalyse.analyse(node, '', '', attribute);\n      },\n      /*\n        进行翻译之后的渲染显示\n        参数：\n          node 当前翻译的node元素\n          originalText 翻译之前的内容文本\n          resultText 翻译之后的内容文本\n          attribute 存放要替换的属性，比如 a标签的title属性。 如果是直接替换node.nodeValue ，那这个没有\n      */\n      set: function (node, originalText, resultText, attribute) {\n        translate.element.nodeAnalyse.analyse(node, originalText, resultText, attribute);\n      },\n      /*\t\n      \t\n        注意，这个不使用，只是服务于上面的get、set使用。具体使用用上面的get、set\n\n        1. 只传入 node：\n          获取node中的要进行翻译的文本内容、以及要操作的实际node对象（这个node对象很可能是传入的node中的某个子node）\n          返回结果是一个数组。其中：\n            ['text']:要进行翻译的text内容文本\n            ['node']:要进行翻译的目标node\n        2. 传入 node、originalText、 resultText\n          则是进行翻译之后的渲染显示\n\n        attribute : 进行替换渲染时使用，存放要替换的属性，比如 a标签的title属性。 如果是直接替换node.nodeValue ，那这个没有\n      */\n      analyse: function (node, originalText, resultText, attribute) {\n        var result = new Array(); //返回的结果\n        result['node'] = node;\n        result['text'] = '';\n\n        var nodename = translate.element.getNodeName(node);\n\n        if (attribute != null && typeof (attribute) == 'string' && attribute.length > 0) {\n          //这个node有属性，替换的是node的属性，而不是nodeValue\n          result['text'] = node[attribute];\n\n          //替换渲染\n          if (typeof (originalText) != 'undefined' && originalText.length > 0) {\n            if (typeof (node[attribute]) != 'undefined') {\n              node[attribute] = node[attribute].replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n            } else {\n              console.log(node);\n            }\n\n          }\n          return result;\n        }\n\n        //正常的node ，typeof 都是 object\n\n        //console.log(typeof(node)+node);\n        if (nodename == '#text') {\n          //如果是普通文本，判断一下上层是否是包含在textarea标签中\n          if (typeof (node.parentNode) != 'undefined') {\n            var parentNodename = translate.element.getNodeName(node.parentNode);\n            //console.log(parentNodename)\n            if (parentNodename == 'TEXTAREA') {\n              //是textarea标签，那将nodename 纳入 textarea的判断中，同时将判断对象交于上级，也就是textarea标签\n              nodename = 'TEXTAREA';\n              node = node.parentNode;\n            }\n          }\n        }\n\n\n\n        //console.log(nodename)\n        //console.log(translate.element.getNodeName(node.parentNode))\n        //console.log(node)\n        if (nodename == 'INPUT' || nodename == 'TEXTAREA') {\n          //console.log(node.attributes)\n          /*\n            1. input、textarea 输入框，要对 placeholder 做翻译\n            2. input 要对 type=button 的情况进行翻译\n          */\n          if (node.attributes == null || typeof (node.attributes) == 'undefined') {\n            result['text'] = '';\n            return result;\n          }\n\n          //input，要对 type=button、submit 的情况进行翻译\n          if (nodename == 'INPUT') {\n            if (typeof (node.attributes.type) != 'undefined' && typeof (node.attributes.type.nodeValue) != null && (node.attributes.type.nodeValue.toLowerCase() == 'button' || node.attributes.type.nodeValue.toLowerCase() == 'submit')) {\n              //console.log('----是 <input type=\"button\"');\n              //取它的value\n              var input_value_node = node.attributes.value;\n              if (input_value_node != null && typeof (input_value_node) != 'undefined' && typeof (input_value_node.nodeValue) != 'undefined' && input_value_node.nodeValue.length > 0) {\n                //替换渲染\n                if (typeof (originalText) != 'undefined' && originalText.length > 0) {\n                  //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n                  input_value_node.nodeValue = input_value_node.nodeValue.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n                }\n\n                result['text'] = input_value_node.nodeValue;\n                result['node'] = input_value_node;\n                return result;\n              }\n            }\n          }\n          //console.log(node)\n\n          //input textarea 的 placeholder 情况\n          if (typeof (node.attributes['placeholder']) != 'undefined') {\n            //console.log(node);\n            //替换渲染\n            if (typeof (originalText) != 'undefined' && originalText.length > 0) {\n              //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n              node.attributes['placeholder'].nodeValue = node.attributes['placeholder'].nodeValue.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n            }\n\n            result['text'] = node.attributes['placeholder'].nodeValue;\n            result['node'] = node.attributes['placeholder'];\n            return result;\n            //return node.attributes['placeholder'].nodeValue;\n          }\n          //console.log(node)\n          result['text'] = '';\n          return result;\n        }\n        if (nodename == 'META') {\n          //meta标签，如是关键词、描述等\n          if (typeof (node.name) != 'undefined' && node.name != null) {\n            var nodeAttributeName = node.name.toLowerCase();  //取meta 标签的name 属性\n            if (nodeAttributeName == 'keywords' || nodeAttributeName == 'description') {\n              //替换渲染\n              if (typeof (originalText) != 'undefined' && originalText.length > 0) {\n                //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n                node.content = node.content.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n              }\n\n              result['text'] = node.content;\n              return result;\n            }\n          }\n\n          result['text'] = '';\n          return result;\n        }\n        if (nodename == 'IMG') {\n          if (typeof (node.alt) == 'undefined' || node.alt == null) {\n            result['text'] = '';\n            return result;\n          }\n\n          //替换渲染\n          if (typeof (originalText) != 'undefined' && originalText.length > 0) {\n            //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            node.alt = node.alt.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n          }\n          result['text'] = node.alt;\n          return result;\n        }\n\n\n        //其他的\n        if (node.nodeValue == null || typeof (node.nodeValue) == 'undefined') {\n          result['text'] = '';\n        } else if (node.nodeValue.trim().length == 0) {\n          //避免就是单纯的空格或者换行\n          result['text'] = '';\n        } else {\n          //替换渲染\n          if (typeof (originalText) != 'undefined' && originalText.length > 0) {\n            //this.nodes[hash][task_index].nodeValue = this.nodes[hash][task_index].nodeValue.replace(new RegExp(translate.util.regExp.pattern(task.originalText),'g'), translate.util.regExp.resultText(task.resultText));\n            node.nodeValue = node.nodeValue.replace(new RegExp(translate.util.regExp.pattern(originalText), 'g'), translate.util.regExp.resultText(resultText));\n          }\n          result['text'] = node.nodeValue;\n        }\n        return result;\n      }\n    },\n    //获取这个node元素的node name ,如果未发现，则返回''空字符串\n    getNodeName: function (node) {\n      if (node == null || typeof (node) == 'undefined') {\n        return '';\n      }\n\n      if (node.nodeName == null || typeof (node.nodeName) == 'undefined') {\n        return '';\n      }\n\n      var nodename = node.nodeName;\n      //console.log('nodename:'+nodename+', node:'+node);\n      return nodename;\n    },\n    //向下遍历node\n    whileNodes: function (uuid, node) {\n      if (node == null || typeof (node) == 'undefined') {\n        return;\n      }\n\n      //如果这个uuid没有，则创建\n      if (typeof (translate.nodeQueue[uuid]) == 'undefined' || translate.nodeQueue[uuid] == null) {\n        translate.nodeQueue[uuid] = new Array(); //创建\n        translate.nodeQueue[uuid]['expireTime'] = Date.now() + 120 * 1000; //删除时间，10分钟后删除\n        translate.nodeQueue[uuid]['list'] = new Array();\n        //console.log('创建 --- ');\n        //console.log(uuid)\n      }\n\n      //console.log('---'+typeof(node)+', ');\n      //判断是否是有title属性，title属性也要翻译\n      if (typeof (node) == 'object' && typeof (node['title']) == 'string' && node['title'].length > 0) {\n        //将title加入翻译队列\n        //console.log('---'+node.title+'\\t'+node.tagName);\n        //console.log(node)\n        //console.log('------------');\n\n        //判断当前元素是否在ignore忽略的tag、id、class name中\n        if (!translate.ignore.isIgnore(node)) {\n          //不在忽略的里面，才会加入翻译\n          translate.addNodeToQueue(uuid, node, node['title'], 'title');\n        }\n      }\n\n      var childNodes = node.childNodes;\n      if (childNodes.length > 0) {\n        for (var i = 0; i < childNodes.length; i++) {\n          translate.element.whileNodes(uuid, childNodes[i]);\n        }\n      } else {\n        //单个了\n        translate.element.findNode(uuid, node);\n      }\n    },\n    findNode: function (uuid, node) {\n      if (node == null || typeof (node) == 'undefined') {\n        return;\n      }\n      //console.log(node)\n      if (node.parentNode == null) {\n        return;\n      }\n      //console.log('-----parent')\n      var parentNodeName = translate.element.getNodeName(node.parentNode);\n      //node.parentNode.nodeName;\n      if (parentNodeName == '') {\n        return;\n      }\n      if (translate.ignore.tag.indexOf(parentNodeName.toLowerCase()) > -1) {\n        //忽略tag\n        //console.log('忽略tag：'+parentNodeName);\n        return;\n      }\n\n      /****** 判断忽略的class ******/\n      /*\n      这段理论上不需要了，因为在  translate.ignore.isIgnore 判断了\n      var ignoreClass = false;\t//是否是被忽略的class，true是\n      var parentNode = node.parentNode;\n      while(node != parentNode && parentNode != null){\n        //console.log('node:'+node+', parentNode:'+parentNode);\n        if(parentNode.className != null){\n          if(translate.ignore.class.indexOf(parentNode.className) > -1){\n            //发现ignore.class 当前是处于被忽略的 class\n            ignoreClass = true;\n          }\n        }\n      \t\n        parentNode = parentNode.parentNode;\n      }\n      if(ignoreClass){\n        //console.log('ignore class :  node:'+node.nodeValue);\n        return;\n      }\n      */\n      /**** 判断忽略的class结束 ******/\n\n\n\n      /**** 避免中途局部翻译，在判断一下 ****/\n      //判断当前元素是否在ignore忽略的tag、id、class name中\n      if (translate.ignore.isIgnore(node)) {\n        //console.log('node包含在要忽略的元素中：');\n        //console.log(node);\n        return;\n      }\n\n      //node分析\n      var nodeAnaly = translate.element.nodeAnalyse.get(node);\n      if (nodeAnaly['text'].length > 0) {\n        //有要翻译的目标内容，加入翻译队列\n        //console.log('addNodeToQueue -- '+nodeAnaly['node']+', text:' + nodeAnaly['text']);\n        translate.addNodeToQueue(uuid, nodeAnaly['node'], nodeAnaly['text']);\n      }\n\n      /*\n      //console.log(node.nodeName+', type:'+node.nodeType+', '+node.nodeValue);\n      var nodename = translate.element.getNodeName(node);\n      if(nodename == 'INPUT' || nodename == 'TEXTAREA'){\n        //input 输入框，要对 placeholder 做翻译\n        console.log('input---'+node.attributes);\n        if(node.attributes == null || typeof(node.attributes) == 'undefined'){\n          return;\n        }\n\t\n        if(typeof(node.attributes['placeholder']) != 'undefined'){\n          //console.log(node.attributes['placeholder'].nodeValue);\n          //加入要翻译的node队列\n          //translate.nodeQueue[translate.hash(node.nodeValue)] = node.attributes['placeholder'];\n          //加入要翻译的node队列\n          //translate.addNodeToQueue(translate.hash(node.attributes['placeholder'].nodeValue), node.attributes['placeholder']);\n          translate.addNodeToQueue(uuid, node.attributes['placeholder'], node.attributes['placeholder'].nodeValue);\n        }\n      \t\n        //console.log(node.getAttribute(\"placeholder\"));\n      }else if(nodename == 'META'){\n        //meta标签，如是关键词、描述等\n        if(typeof(node.name) != 'undefined' && node.name != null){\n          var nodeAttributeName = node.name.toLowerCase();  //取meta 标签的name 属性\n          //console.log(nodeName);\n          if(nodeAttributeName == 'keywords' || nodeAttributeName == 'description'){\n            //关键词、描述\n            translate.addNodeToQueue(uuid, node, node.content);\n          }\n        }\n        //console.log(node.name)\n      }else if(nodename == 'IMG'){\n        //console.log('-------'+node.alt);\n        translate.addNodeToQueue(uuid, node, node.alt);\n      }else if(node.nodeValue != null && node.nodeValue.trim().length > 0){\n\t\n        //过滤掉无效的值\n        if(node.nodeValue != null && typeof(node.nodeValue) == 'string' && node.nodeValue.length > 0){\n        }else{\n          return;\n        }\n\t\n        //console.log(node.nodeValue+' --- ' + translate.language.get(node.nodeValue));\n      \t\n        //console.log(node.nodeName);\n        //console.log(node.parentNode.nodeName);\n        //console.log(node.nodeValue);\n        //加入要翻译的node队列\n        translate.addNodeToQueue(uuid, node, node.nodeValue);\t\n        //translate.addNodeToQueue(translate.hash(node.nodeValue), node);\n        //translate.nodeQueue[translate.hash(node.nodeValue)] = node;\n        //translate.nodeQueue[translate.hash(node.nodeValue)] = node.nodeValue;\n        //node.nodeValue = node.nodeValue+'|';\n\t\n      }\n      */\n\n    },\n  },\n\n\n\n\n\n  /*\n   * 将发现的元素节点加入待翻译队列\n   * uuid execute方法执行的唯一id\n   * node 当前text所在的node\n   * text 当前要翻译的目标文本\n   * attribute 是否是元素的某个属性。比如 a标签中的title属性， a.title 再以node参数传入时是string类型的，本身并不是node类型，所以就要传入这个 attribute=title 来代表这是a标签的title属性。同样第二个参数node传入的也不能是a.title，而是传入a这个node元素\n   */\n  addNodeToQueue: function (uuid, node, text, attribute) {\n    if (node == null || text == null || text.length == 0) {\n      return;\n    }\n    //console.log('find tag ignore : '+node.nodeValue+', '+node.nodeName+\", \"+node.nodeType+\", \"+node.tagName);\n    //console.log('addNodeToQueue into -- node:'+node+', text:'+text+', attribute:'+attribute);\n    var nodename = translate.element.getNodeName(node);\n\n    //判断如果是被 <!--  --> 注释的区域，不进行翻译\n    if (nodename.toLowerCase() == '#comment') {\n      return;\n    }\n    //console.log('\\t\\t'+text);\n    //取要翻译字符的hash\n    var key = translate.util.hash(text);\n    /*\n    如果是input 的 placeholder ,就会出现这个情况\n    if(node.parentNode == null){\n      console.log('node.parentNode == null');\n      return;\n    }\n    */\n\n    //console.log(node.parentNode);\n    //console.log(node.parentNode.nodeName);\n\n    if (translate.util.findTag(text)) {\n      //console.log('find tag ignore : '+node.nodeValue+', '+node.nodeName+\", \"+node.nodeType+\", \"+node.tagName);\n      //console.log(node.parentNode.nodeName);\n\n      //获取到当前文本是属于那个tag标签中的，如果是script、style 这样的标签中，那也会忽略掉它，不进行翻译\n      if (node.parentNode == null) {\n        //没有上级了，或是没获取到上级，忽略\n        return;\n      }\n      //去上级的tag name\n      var parentNodeName = translate.element.getNodeName(node.parentNode);\n      //node.parentNode.nodeName;\n      if (parentNodeName == 'SCRIPT' || parentNodeName == 'STYLE') {\n        //如果是script、style中发现的，那也忽略\n        return;\n      }\n    }\n    //console.log(node.nodeValue);\n\n    //获取当前是什么语种\n    var langs = translate.language.get(text);\n    //console.log('langs');\n    //console.log(langs);\n\n    //过滤掉要转换为的目标语种，比如要转为英语，那就将本来是英语的部分过滤掉，不用再翻译了\n    if (typeof (langs[translate.to]) != 'undefined') {\n      delete langs[translate.to];\n    }\n\n    /* if(this.nodeQueue[lang] == null || typeof(this.nodeQueue[lang]) == 'undefined'){\n      this.nodeQueue[lang] = new Array();\n    } \n    //创建二维数组\n    if(this.nodeQueue[lang][key] == null || typeof(this.nodeQueue[lang][key]) == 'undefined'){\n      this.nodeQueue[lang][key] = new Array();\n    }\n    */\n    //console.log(langs);\n\n    for (var lang in langs) {\n      //创建二维数组， key为语种，如 english\n      if (translate.nodeQueue[uuid]['list'][lang] == null || typeof (translate.nodeQueue[uuid]['list'][lang]) == 'undefined') {\n        translate.nodeQueue[uuid]['list'][lang] = new Array();\n      }\n      //console.log('|'+langs[lang].length);\n      //遍历出该语种下有哪些词需要翻译\n      for (var word_index = 0; word_index < langs[lang].length; word_index++) {\n        //console.log('start:'+word_index)\n        //console.log(langs[lang][word_index]);\n        if (typeof (langs[lang][word_index]) == 'undefined' || typeof (langs[lang][word_index]['text']) == 'undefined') {\n          //理论上应该不会，但多加个判断\n          continue;\n        }\n        var word = langs[lang][word_index]['text']; //要翻译的词\n        var beforeText = langs[lang][word_index]['beforeText'];\n        var afterText = langs[lang][word_index]['afterText'];\n\n        //console.log(\"word:\"+word+', bef:'+beforeText+', after:'+afterText)\n        var hash = translate.util.hash(word); \t//要翻译的词的hash\n        //console.log(hash);\n\n        //创建三维数组， key为要通过接口翻译的文本词或句子的 hash （注意并不是node的文本，而是node拆分后的文本）\n        if (translate.nodeQueue[uuid]['list'][lang][hash] == null || typeof (translate.nodeQueue[uuid]['list'][lang][hash]) == 'undefined') {\n          translate.nodeQueue[uuid]['list'][lang][hash] = new Array();\n\n          /*\n           * 创建四维数组，存放具体数据\n           * key: nodes 包含了这个hash的node元素的数组集合，array 多个。其中\n                nodes[index]['node'] 存放当前的node元素\n                nodes[index]['attribute'] 存放当前hash，也就是翻译文本针对的是什么，是node本身（nodeValue），还是 node 的某个属性，比如title属性。如果这里不为空，那就是针对的属性操作的\n           * key: original 原始的要翻译的词或句子，html加载完成但还没翻译前的文本，用于支持当前页面多次语种翻译切换而无需跳转\n           * beforeText、afterText:见 translate.nodeQueue 的说明\n           */\n          translate.nodeQueue[uuid]['list'][lang][hash]['nodes'] = new Array();\n          translate.nodeQueue[uuid]['list'][lang][hash]['original'] = word;\n          translate.nodeQueue[uuid]['list'][lang][hash]['translateText'] = translate.nomenclature.dispose(word); //自定义术语处理\n          translate.nodeQueue[uuid]['list'][lang][hash]['beforeText'] = beforeText;\n          translate.nodeQueue[uuid]['list'][lang][hash]['afterText'] = afterText;\n          //translate.nodeQueue[uuid]['list'][lang][hash]['attribute'] = attribute; //放入 nodes[index][attribute] 元素中\n\n          //其中key： nodes 是第四维数组，里面存放具体的node元素对象\n\n\n          //console.log(translate.nodeQueue[uuid]['list'][lang][hash]);\n        }\n\n        if (typeof (node.isSameNode) != 'undefined') {\t//支持 isSameNode 方法判断对象是否相等\n          for (var node_index = 0; node_index < translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length; node_index++) {\n            if (node.isSameNode(translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][node_index]['node'])) {\n              //相同，那就不用在存入了\n              //console.log('相同，那就不用在存入了')\n              //console.log(node)\n              continue;\n            }\n          }\n        }\n\n        //往五维数组nodes中追加node元素\n        var nodesIndex = translate.nodeQueue[uuid]['list'][lang][hash]['nodes'].length;\n        translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][nodesIndex] = new Array();\n        translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][nodesIndex]['node'] = node;\n        translate.nodeQueue[uuid]['list'][lang][hash]['nodes'][nodesIndex]['attribute'] = attribute;\n        //console.log('end:'+word_index)\n      }\n\n    }\n\n\n\n    //this.nodeQueue[lang][key][this.nodeQueue[lang][key].length]=node; //往数组中追加\n  },\n\n  language: {\n    //当前本地语种，本地语言，默认是简体中文。设置请使用 translate.language.setLocal(...)。不可直接使用，使用需用 getLocal()\n    local: '',\n    //传入语种。具体可传入哪些参考： http://api.translate.zvo.cn/doc/language.json.html\n    setLocal: function (languageName) {\n      translate.setUseVersion2(); //Set to use v2.x version\n      translate.language.local = languageName;\n    },\n    //获取当前本地语种，本地语言，默认是简体中文。设置请使用 translate.language.setLocal(...)\n    getLocal: function () {\n      //判断是否设置了本地语种，如果没设置，自动给其设置\n      if (translate.language.local == null || translate.language.local.length < 1) {\n        translate.language.autoRecognitionLocalLanguage();\n      }\n      return translate.language.local;\n    },\n    /*\n      获取当前语种。\n      比如当前设置的本地语种是简体中文，用户并未切换其他语种，那么这个方法将返回本地当前的语种，也就是等同于 translate.language.getLocal()\n      如果用户切换为英语进行浏览，那么这个方法将返回翻译的目标语种，也就是 english\n    */\n    getCurrent: function () {\n      var to_storage = translate.storage.get('to');\n      if (to_storage != null && typeof (to_storage) != 'undefined' && to_storage.length > 0) {\n        //之前有过使用，并且主动设置过目标语种\n        return to_storage;\n      }\n      return translate.language.getLocal();\n    },\n    //如果第一次用，默认以什么语种显示。\n    //比如本地当前语种是简体中文，这里设置为english，那么用户第一次使用时，会自动翻译为english进行显示。如果用户手动切换为其他语种比如韩语，那么就遵循用户手动切换的为主，显示韩语。\n    setDefaultTo: function (languageName) {\n      var to_storage = translate.storage.get('to');\n      if (to_storage != null && typeof (to_storage) != 'undefined' && to_storage.length > 0) {\n        //之前有过使用，并且主动设置过目标语种，那么不进行处理\n      } else {\n        //没有设置过，进行处理\n        translate.storage.set('to', languageName);\n        translate.to = languageName;\n      }\n    },\n    //根据URL传参控制以何种语种显示\n    //设置可以根据当前访问url的某个get参数来控制使用哪种语言显示。\n    //比如当前语种是简体中文，网页url是http://translate.zvo.cn/index.html ,那么可以通过在url后面增加 language 参数指定翻译语种，来使网页内容以英文形态显示 http://translate.zvo.cn/index.html?language=english\n    setUrlParamControl: function (paramName) {\n      if (typeof (paramName) == 'undefined' || paramName.length < 1) {\n        paramName = 'language';\n      }\n      var paramValue = translate.util.getUrlParam(paramName);\n      if (typeof (paramValue) == 'undefined') {\n        return;\n      }\n      if (paramValue == '' || paramValue == 'null' || paramValue == 'undefined') {\n        return;\n      }\n\n      translate.storage.set('to', paramValue);\n      translate.to = paramValue;\n    },\n    //自动识别当前页面是什么语种\n    autoRecognitionLocalLanguage: function () {\n      if (translate.language.local != null && translate.language.local.length > 2) {\n        //已设置过了，不需要再设置\n        return;\n      }\n\n      var bodyText = document.body.outerText;\n      if (bodyText == null || typeof (bodyText) == 'undefined' || bodyText.length < 1) {\n        //未取到，默认赋予简体中文\n        translate.language.local = 'chinese_simplified';\n        return;\n      }\n\n      bodyText = bodyText.replace(/\\n|\\t|\\r/g, ''); //将回车换行等去掉\n\n      var langs = new Array(); //上一个字符的语种是什么，当前字符向上数第一个字符。格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。 \n      for (var i = 0; i < bodyText.length; i++) {\n        var charstr = bodyText.charAt(i);\n        var lang = translate.language.getCharLanguage(charstr);\n        if (lang == '') {\n          //未获取到，未发现是什么语言\n          //continue;\n          lang = 'unidentification';\n        }\n        langs.push(lang);\n      }\n\n      //从数组中取出现频率最高的\n      var newLangs = translate.util.arrayFindMaxNumber(langs);\n\n      //移除数组中的特殊字符\n      var index = newLangs.indexOf('specialCharacter');\n      if (index > -1) {\n        newLangs.splice(index, 1); //移除数组中的特殊字符\n      }\n\n      if (newLangs.length > 0) {\n        //找到排序出现频率最多的\n        translate.language.local = newLangs[0];\n      } else {\n        //没有，默认赋予简体中文\n        translate.language.local = 'chinese_simplified';\n      }\n    },\n\n    /*\n     * 获取当前字符是什么语种。返回值是一个语言标识，有  chinese_simplified简体中文、japanese日语、korean韩语、\n     * str : node.nodeValue 或 图片的 node.alt 等\n     * 如果语句长，会全句翻译，以保证翻译的准确性，提高可读性。\n     * 如果语句短，会自动将特殊字符、要翻译的目标语种给过滤掉，只取出具体的要翻译的目标语种文本\n     */\n    get: function (str) {\n      //将str拆分为单个char进行判断\n\n      var langs = new Array(); //当前字符串包含哪些语言的数组，其内如 english\n      var langStrs = new Array();\t//存放不同语言的文本，格式如 ['english'][0] = 'hello'\n      var upLangs = []; //上一个字符的语种是什么，当前字符向上数第一个字符。格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。 \n      var upLangsTwo = []; //上二个字符的语种是什么 ，当前字符向上数第二个字符。 格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。\n\n      //var upLangs = ''; //上一个字符的语种是什么，格式如 english\n      for (var i = 0; i < str.length; i++) {\n        var charstr = str.charAt(i);\n        //console.log('charstr:'+charstr)\n        var lang = translate.language.getCharLanguage(charstr);\n        if (lang == '') {\n          //未获取到，未发现是什么语言\n          //continue;\n          lang = 'unidentification';\n        }\n\n        var result = translate.language.analyse(lang, langStrs, upLangs, upLangsTwo, charstr);\n        //console.log(result)\n        langStrs = result['langStrs'];\n        //记录上几个字符\n        if (typeof (upLangs['language']) != 'undefined') {\n          upLangsTwo['language'] = upLangs['language'];\n          upLangsTwo['charstr'] = upLangs['charstr'];\n          upLangsTwo['storage_language'] = upLangs['storage_language'];\n        }\n        //upLangs['language'] = lang;\n        upLangs['language'] = result['storage_language'];\n        upLangs['charstr'] = charstr;\n        upLangs['storage_language'] = result['storage_language'];\n        //console.log(result['storage_language'])\n        //console.log(upLangs['language']);\n        langs.push(lang);\n      }\n\n      //console.log(langStrs);\n\n      //console.log(langs);\n      //console.log(langStrs);\n\n      /*\n            //从数组中取出现频率最高的\n            var newLangs = translate.util.arrayFindMaxNumber(langs);\n          \t\n            //移除当前翻译目标的语言。因为已经是目标预言了，不需要翻译了\n            var index = newLangs.indexOf(translate.to);\n            if(index > -1){\n              newLangs.splice(index,1); //移除\n            }\n      \n            //移除特殊字符\n            var index = newLangs.indexOf('specialCharacter');\n            if(index > -1){\n              newLangs.splice(index,1); //移除数组中的特殊字符\n            }\n      \n            if(newLangs.length > 0){\n              //还剩一个或多个，（如果是多个，那应该是这几个出现的频率一样，所以取频率最高的时返回了多个）\n              return newLangs[0];\n            }else{\n              //没找到，直接返回空字符串\n              return '';\n            }\n            */\n\n\n      //去除特殊符号\n      //for(var i = 0; i<langStrs.length; i++){\n      /*\n      var i = 0;\n      for(var item in langStrs) {\n        if(item == 'unidentification' || item == 'specialCharacter'){\n          //langStrs.splice(i,1); //移除\n          delete langStrs[item];\n        }\n        console.log(item);\n        i++;\n      }\n      */\n\n      //console.log(langStrs);\n      if (typeof (langStrs['unidentification']) != 'undefined') {\n        delete langStrs['unidentification'];\n      }\n      if (typeof (langStrs['specialCharacter']) != 'undefined') {\n        delete langStrs['specialCharacter'];\n      }\n      if (typeof (langStrs['number']) != 'undefined') {\n        delete langStrs['number'];\n      }\n\n\n      //console.log('get end');\n      return langStrs;\n    },\n    // 传入一个char，返回这个char属于什么语种，返回如 chinese_simplified、english  如果返回空字符串，那么表示未获取到是什么语种\n    getCharLanguage: function (charstr) {\n      if (charstr == null || typeof (charstr) == 'undefined') {\n        return '';\n      }\n\n      if (this.english(charstr)) {\n        return 'english';\n      } else if (this.specialCharacter(charstr)) {\n        return 'specialCharacter';\n      } else if (this.number(charstr)) {\n        return 'number';\n      } else if (this.chinese_simplified(charstr)) {\n        return 'chinese_simplified';\n      } else if (this.japanese(charstr)) {\n        return 'japanese';\n      } else if (this.korean(charstr)) {\n        return 'korean';\n      } else {\n        console.log('not find is language , char : ' + charstr + ', unicode: ' + charstr.charCodeAt(0).toString(16));\n        return '';\n      }\n    },\n    /*\n     * 对字符串进行分析，分析字符串是有哪几种语言组成。\n     * language : 当前字符的语种，传入如 english\n     * langStrs : 操作的，如 langStrs['english'][0] = '你好'\n     * upLangs  : 当前字符之前的上一个字符的语种是什么，当前字符向上数第一个字符。格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。\n     * upLangsTwo : 当前字符之前的上二个字符的语种是什么 ，当前字符向上数第二个字符。 格式如 ['language']='english', ['chatstr']='a', ['storage_language']='english'  这里面有3个参数，分别代表这个字符属于那个语种，其字符是什么、存入了哪种语种的队列。因为像是逗号，句号，一般是存入本身语种中，而不是存入特殊符号中。\n     * chatstr  : 当前字符，如  h\n     */\n    analyse: function (language, langStrs, upLangs, upLangsTwo, charstr) {\n      if (typeof (langStrs[language]) == 'undefined') {\n        langStrs[language] = new Array();\n      }\n      var index = 0; //当前要存入的数组下标\n      if (typeof (upLangs['storage_language']) == 'undefined') {\n        //第一次，那么还没存入值，index肯定为0\n        //console.log('第一次，那么还没存入值，index肯定为0')\n        //console.log(upLangs['language'])\n      } else {\n        //console.log('analyse, charstr : '+charstr+', upLangs :');\n        //console.log(upLangs);\n        //var isEqual = upLangs['storage_language'] == language; //上次跟当前字符是否都是同一个语种（这个字符跟这个字符前一个字符）\n\n        /*\n          英语每个单词之间都会有空格分割. 如果是英文的话，英文跟特殊字符还要单独判断一下，避免拆开，造成翻译不准，单个单词翻译的情况\n          所以如果上次的字符是英文或特殊符号，当前字符是特殊符号(逗号、句号、空格，然后直接笼统就吧特殊符号都算上吧)，那么也将当次的特殊符号变为英文来进行适配\n          示例  \n            hello word  的 \"o w\"\n            hello  word  的 \"  w\"\n            hello  word  的 \"w  \"\n            this is a dog  的 \" a \"\n        */\n        //console.log(language == 'specialCharacter');\n        //如果两个字符类型不一致，但当前字符是英文或连接符时，进行判断\n        /*\n        if(!isEqual){\n          if(language == 'english' || translate.language.connector(charstr)){\n            console.log('1.'+(language == 'english' || translate.language.connector(charstr))+', upLangs str:'+upLangs['charstr']);\n            //上一个字符是英文或连接符\n            //console.log('teshu:'+translate.language.connector(upLangs['charstr'])+', str:'+upLangs['charstr']);\n            if(upLangs['language'] == 'english' || translate.language.connector(upLangs['charstr'])) {\n              console.log('2');\n              //如果上二个字符不存在，那么刚开始，不再上面几种情况之中，直接不用考虑\n              if(typeof(upLangsTwo['language']) != 'undefined'){\n                console.log('3')\n                //上二个字符是空（字符串刚开始），或者是英文\n                if(upLangsTwo['language'] == 'english' || translate.language.connector(upLangsTwo['charstr'])){\n                  //满足这三个条件，那就将这三个拼接到一起\n                  console.log('4/5: '+', two lang:'+upLangsTwo['language']+', str:'+upLangsTwo['charstr'])\n                  isEqual = true;\n                  if(language == 'specialCharacter' && upLangs['language'] == 'specialCharacter' && upLangsTwo['language'] == 'specialCharacter'){\n                    //如果三个都是特殊字符，或后两个是特殊字符，第一个是空（刚开始），那就归入特殊字符\n                    language = 'specialCharacter';\n                    //console.log('4')\n                  }else{\n                    //不然就都归于英文中。\n                    //这里更改是为了让下面能将特殊字符（像是空格逗号等）也一起存入数组\n                    language = 'english';\n                    console.log(5)\n                  }\n                }\n              }\n            }\n          }\n        }\n        */\n\n        /*\n          不判断当前字符，而判断上个字符，是因为当前字符没法获取未知的下个字符。\n        */\n        //if(!isEqual){\n\n        //如果当前字符是连接符\n        if (translate.language.connector(charstr)) {\n          language = upLangs['storage_language'];\n          /*\n          //判断上个字符是否存入了待翻译字符，如要将中文翻译为英文，而上个字符是中文，待翻译，那将连接符一并加入待翻译字符中去，保持句子完整性\n          //判断依据是上个字符存储至的翻译字符语种序列，不是特殊字符，而且也不是要翻译的目标语种，那肯定就是待翻译的，将连接符加入待翻译中一起进行翻译\n          if(upLangs['storage_language'] != 'specialCharacter' && upLangs['storage_language'] != translate.to){\n          \t\n            language = upLangs['storage_language'];\n            console.log('teshu:'+charstr+', 当前字符并入上个字符存储翻译语种:'+upLangs['storage_language']);\n          }\n          */\n        }\n        //}\n\n        //console.log('isEqual:'+isEqual);\n        /*\n        if(isEqual){\n          //跟上次语言一样，那么直接拼接\n          index = langStrs[language].length-1; \n          //但是还有别的特殊情况，v2.1针对英文翻译准确度的适配，会有特殊字符的问题\n          if(typeof(upLangs['storage_language']) != 'undefined' && upLangs['storage_language'] != language){\n            //如果上个字符存入的翻译队列跟当前这个要存入的队列不一个的话，那应该是特殊字符像是逗号句号等导致的，那样还要额外一个数组，不能在存入之前的数组了\n            index = langStrs[language].length; \n          }\n        }else{\n          //console.log('新开');\n          //当前字符跟上次语言不样，那么新开一个数组\n          index = langStrs[language].length;\n          //console.log('++, inde:'+index+',lang:'+language+', length:'+langStrs[language].length)\n        }\n        */\n\n        //当前要翻译的语种跟上个字符要翻译的语种一样，那么直接拼接\n        if (upLangs['storage_language'] == language) {\n          index = langStrs[language].length - 1;\n        } else {\n          //console.log('新开');\n          //当前字符跟上次语言不样，那么新开一个数组\n          index = langStrs[language].length;\n        }\n      }\n      if (typeof (langStrs[language][index]) == 'undefined') {\n        langStrs[language][index] = new Array();\n        langStrs[language][index]['beforeText'] = '';\n        langStrs[language][index]['afterText'] = '';\n        langStrs[language][index]['text'] = '';\n      }\n      langStrs[language][index]['text'] = langStrs[language][index]['text'] + charstr;\n      /*\n        中文英文混合时，当中文+英文并没有空格间隔，翻译为英文时，会使中文翻译英文的结果跟原本的英文单词连到一块。这里就是解决这种情况\n        针对当前非英文(不需要空格分隔符，像是中文、韩语)，但要翻译为英文（需要空格作为分割符号，像是法语等）时的情况进行判断\n      */\n      //if(translate.language.getLocal() != 'english' && translate.to == 'english'){\n      //当前本地语种的语言是连续的，但翻译的目标语言不是连续的（空格间隔）\n      if (translate.language.wordBlankConnector(translate.language.getLocal()) == false && translate.language.wordBlankConnector(translate.to)) {\n        if ((upLangs['storage_language'] != null && typeof (upLangs['storage_language']) != 'undefined' && upLangs['storage_language'].length > 0)) {\n          //上个字符存在\n          //console.log(upLangs['storage_language']);\n          if (upLangs['storage_language'] != 'specialCharacter') {\n            //上个字符不是特殊字符 （是正常语种。且不会是连接符，连接符都并入了正常语种）\n\n            //if( upLangs['storage_language'] != 'english' && language == 'english'){\n            //上个字符的语言是连续的，但当前字符的语言不是连续的（空格间隔）\n            if (translate.language.wordBlankConnector(upLangs['storage_language']) == false && translate.language.wordBlankConnector(language)) {\n              //上个字符不是英语，当前字符是英语，这种情况要在上个字符后面追加空格，因为当前字符是英文，就不会在执行翻译操作了\n              //console.log(upLangs['language']);\n              langStrs[upLangs['storage_language']][langStrs[upLangs['storage_language']].length - 1]['afterText'] = ' ';\n            } else if (upLangs['storage_language'] == 'english' && language != 'english') {\n              //上个字符是英语，当前字符不是英语，直接在当前字符前面追加空格\n              langStrs[language][index]['beforeText'] = ' ';\n            }\n          }\n\n\n        }\n      }\n\n      var result = new Array();\n      result['langStrs'] = langStrs;\n      result['storage_language'] = language;\t//实际存入了哪种语种队列\n      //console.log(result);\n      //console.log(langStrs)\n      //console.log(charstr);\n      return result;\n    },\n\n    /*\n     * 不同于语言，这个只是单纯的连接符。比如英文单词之间有逗号、句号、空格， 汉字之间有逗号句号书名号的。避免一行完整的句子被分割，导致翻译不准确\n     * 单独拿他出来，目的是为了更好的判断计算，提高翻译的准确率\n     */\n    connector: function (str) {\n\n      /*\n        通用的有 空格、阿拉伯数字\n        1.不间断空格\\u00A0,主要用在office中,让一个单词在结尾处不会换行显示,快捷键ctrl+shift+space ;\n        2.半角空格(英文符号)\\u0020,代码中常用的;\n        3.全角空格(中文符号)\\u3000,中文文章中使用; \n      */\n      if (/.*[\\u0020\\u00A0\\u202F\\u205F\\u3000]+.*$/.test(str)) {\n        return true;\n      }\n      /*\n        U+0030 0 数字 0\n        U+0031 1 数字 1\n        U+0032 2 数字 2\n        U+0033 3 数字 3\n        U+0034 4 数字 4\n        U+0035 5 数字 5\n        U+0036 6 数字 6\n        U+0037 7 数字 7\n        U+0038 8 数字 8\n        U+0039 9 数字 9\n      */\n      if (/.*[\\u0030-\\u0039]+.*$/.test(str)) {\n        return true\n      }\n\n\n      /*\n        英文场景\n        英文逗号、句号\n        这里不包括() 因为这里面的基本属于补充，对语句前后并无强依赖关系\n      \t\n        U+0021 ! 叹号\n        U+0022 \" 双引号\n        U+0023 # 井号\n        U+0024 $ 价钱/货币符号\n        U+0025 % 百分比符号\n        U+0026 & 英文“and”的简写符号\n        U+0027 ' 引号\n        U+002C , 逗号\n        U+002D - 连字号/减号\n        U+002E . 句号\n        U+003A : 冒号\n        U+003B ; 分号\n        U+003F ? 问号\n        U+0040 @ 英文“at”的简写符号\n\n\n      */\n      if (/.*[\\u0021\\u0022\\u0023\\u0024\\u0025\\u0026\\u0027\\u002C\\u002D\\u002E\\u003A\\u003B\\u003F\\u0040]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n        中文标点符号\n        名称\tUnicode\t符号\n        句号\t3002\t。\n        问号\tFF1F\t？\n        叹号\tFF01\t！\n        逗号\tFF0C\t，\n        顿号\t3001\t、\n        分号\tFF1B\t；\n        冒号\tFF1A\t：\n        引号\t300C\t「\n            300D\t」\n        引号\t300E\t『\n            300F\t』\n        引号\t2018\t‘\n            2019\t’\n        引号\t201C\t“\n            201D\t”\n        括号\tFF08\t（\n            FF09\t）\n        括号\t3014\t〔\n            3015\t〕\n        括号\t3010\t【\n            3011\t】\n        破折号\t2014\t—\n        省略号\t2026\t…\n        连接号\t2013\t–\n        间隔号\tFF0E\t．\n        书名号\t300A\t《\n            300B\t》\n        书名号\t3008\t〈\n            3009\t〉\n        键盘123前面的那个符号 · 00b7\n      */\n      if (/.*[\\u3002\\uFF1F\\uFF01\\uFF0C\\u3001\\uFF1B\\uFF1A\\u300C\\u300D\\u300E\\u300F\\u2018\\u2019\\u201C\\u201D\\uFF08\\uFF09\\u3014\\u3015\\u3010\\u3011\\u2014\\u2026\\u2013\\uFF0E\\u300A\\u300B\\u3008\\u3009\\u00b7]+.*$/.test(str)) {\n        return true;\n      }\n\n\n\n\n      //不是，返回false\n      return false;\n    },\n    //语种的单词连接符是否需要空格，比如中文、韩文、日语都不需要空格，则返回false, 但是像是英文的单词间需要空格进行隔开，则返回true\n    //如果未匹配到，默认返回true\n    //language：语种，传入如  english\n    wordBlankConnector: function (language) {\n      if (language == null || typeof (language) == 'undefined') {\n        return true;\n      }\n      switch (language.trim().toLowerCase()) {\n        case 'chinese_simplified':\n          return false;\n        case 'chinese_traditional':\n          return false;\n        case 'korean':\n          return false;\n        case 'japanese':\n          return false;\n      }\n      //其他情况则返回true\n      return true;\n    },\n    //是否包含中文，true:包含\n    chinese_simplified: function (str) {\n      if (/.*[\\u4e00-\\u9fa5]+.*$/.test(str)) {\n        return true\n      } else {\n        return false;\n      }\n    },\n    //是否包含英文，true:包含\n    english: function (str) {\n      if (/.*[\\u0041-\\u005a]+.*$/.test(str)) {\n        return true;\n      } else if (/.*[\\u0061-\\u007a]+.*$/.test(str)) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    //是否包含日语，true:包含\n    japanese: function (str) {\n      if (/.*[\\u0800-\\u4e00]+.*$/.test(str)) {\n        return true\n      } else {\n        return false;\n      }\n    },\n    //是否包含韩语，true:包含\n    korean: function (str) {\n      if (/.*[\\uAC00-\\uD7AF]+.*$/.test(str)) {\n        return true\n      } else {\n        return false;\n      }\n    },\n    //0-9 阿拉伯数字\n    number: function (str) {\n      if (/.*[\\u0030-\\u0039]+.*$/.test(str)) {\n        return true;\n      }\n      return false;\n    },\n    //是否包含特殊字符\n    specialCharacter: function (str) {\n      //如：① ⑴ ⒈ \n      if (/.*[\\u2460-\\u24E9]+.*$/.test(str)) {\n        return true\n      }\n\n      //如：┊┌┍ ▃ ▄ ▅\n      if (/.*[\\u2500-\\u25FF]+.*$/.test(str)) {\n        return true\n      }\n\n      //如：㈠  ㎎ ㎏ ㎡\n      if (/.*[\\u3200-\\u33FF]+.*$/.test(str)) {\n        return true\n      }\n\n      //如：与ANSI对应的全角字符\n      if (/.*[\\uFF00-\\uFF5E]+.*$/.test(str)) {\n        return true\n      }\n\n      //其它特殊符号\n      if (/.*[\\u2000-\\u22FF]+.*$/.test(str)) {\n        return true\n      }\n\n      // 、><等符号\n      if (/.*[\\u3001-\\u3036]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n      //阿拉伯数字 0-9\n      if(/.*[\\u0030-\\u0039]+.*$/.test(str)){\n        return true;\n      }\n      */\n\n      /*\n      U+0020 空格\n      U+0021 ! 叹号\n      U+0022 \" 双引号\n      U+0023 # 井号\n      U+0024 $ 价钱/货币符号\n      U+0025 % 百分比符号\n      U+0026 & 英文“and”的简写符号\n      U+0027 ' 引号\n      U+0028 ( 开 左圆括号\n      U+0029 ) 关 右圆括号\n      U+002A * 星号\n      U+002B + 加号\n      U+002C , 逗号\n      U+002D - 连字号/减号\n      U+002E . 句号\n      U+002F / 左斜杠\n      */\n      if (/.*[\\u0020-\\u002F]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n        U+003A : 冒号\n        U+003B ; 分号\n        U+003C < 小于符号\n        U+003D = 等于号\n        U+003E > 大于符号\n        U+003F ? 问号\n        U+0040 @ 英文“at”的简写符号\n        U+0041 A 拉丁字母 A\n        U+0042 B 拉丁字母 B\n        U+0043 C 拉丁字母 C\n        U+0044 D 拉丁字母 D\n        U+0045 E 拉丁字母 E\n        U+0046 F 拉丁字母 F\n        U+0047 G 拉丁字母 G\n        U+0048 H 拉丁字母 H\n        U+0049 I 拉丁字母 I\n        U+004A J 拉丁字母 J\n        U+004B K 拉丁字母 K\n        U+004C L 拉丁字母 L\n        U+004D M 拉丁字母 M\n        U+004E N 拉丁字母 N\n        U+004F O 拉丁字母 O\n        U+0050 P 拉丁字母 P\n        U+0051 Q 拉丁字母 Q\n        U+0052 R 拉丁字母 R\n        U+0053 S 拉丁字母 S\n        U+0054 T 拉丁字母 T\n        U+0055 U 拉丁字母 U\n        U+0056 V 拉丁字母 V\n        U+0057 W 拉丁字母 W\n        U+0058 X 拉丁字母 X\n        U+0059 Y 拉丁字母 Y\n        U+005A Z 拉丁字母 Z\n        U+005B [ 开 方括号\n        U+005C \\ 右斜杠\n        U+005D ] 关 方括号\n        U+005E ^ 抑扬（重音）符号\n        U+005F _ 底线\n        U+0060 ` 重音符\n        U+0061 a 拉丁字母 a\n        U+0062 b 拉丁字母 b\n        U+0063 c 拉丁字母 c\n        U+0064 d 拉丁字母 d\n        U+0065 e 拉丁字母 e\n        U+0066 f 拉丁字母 f\n        U+0067 g 拉丁字母 g\n        U+0068 h 拉丁字母 h\n        U+0069 i 拉丁字母 i\n        U+006A j 拉丁字母 j\n        U+006B k 拉丁字母 k\n        U+006C l 拉丁字母 l（L的小写）\n        U+006D m 拉丁字母 m\n        U+006E n 拉丁字母 n\n        U+006F o 拉丁字母 o\n        U+0070 p 拉丁字母 p\n        U+0071 q 拉丁字母 q\n        U+0072 r 拉丁字母 r\n        U+0073 s 拉丁字母 s\n        U+0074 t 拉丁字母 t\n        U+0075 u 拉丁字母 u\n        U+0076 v 拉丁字母 v\n        U+0077 w 拉丁字母 w\n        U+0078 x 拉丁字母 x\n        U+0079 y 拉丁字母 y\n        U+007A z 拉丁字母 z\n        U+007B { 开 左花括号\n        U+007C | 直线\n        U+007D } 关 右花括号\n        U+007E ~ 波浪纹\n      */\n      if (/.*[\\u003A-\\u007E]+.*$/.test(str)) {\n        return true;\n      }\n\n      //空白字符，\\u0009\\u000a + https://cloud.tencent.com/developer/article/2128593\n      if (/.*[\\u0009\\u000a\\u0020\\u00A0\\u1680\\u180E\\u202F\\u205F\\u3000\\uFEFF]+.*$/.test(str)) {\n        return true;\n      }\n      if (/.*[\\u2000-\\u200B]+.*$/.test(str)) {\n        return true;\n      }\n\n      /*\n      拉丁字母\n      代码 显示 描述\n      U+00A1 ¡ 倒转的叹号\n      U+00A2 ¢ （货币单位）分钱、毫子\n      U+00A3 £ （货币）英镑\n      U+00A4 ¤ （货币）当货币未有符号时以此替代\n      U+00A5 ¥ （货币）日元\n      U+00A6 ¦ 两条断开的直线\n      U+00A7 § 文件分不同部分\n      U+00A8 ¨ （语言）分音\n      U+00A9 © 版权符\n      U+00AA ª （意大利文、葡萄牙文、西班牙文）阴性序数\n      U+00AB « 双重角形引号\n      U+00AC ¬ 逻辑非\n      U+00AE ® 商标\n      U+00AF ¯ 长音\n      U+00B0 ° 角度\n      U+00B1 ± 正负号\n      U+00B2 ² 二次方\n      U+00B3 ³ 三次方\n      U+00B4 ´ 锐音符\n      U+00B5 µ 百万分之一，10?6\n      U+00B6 ¶ 文章分段\n      U+00B7 · 间隔号\n      U+00B8 ¸ 软音符\n      U+00B9 ¹ 一次方\n      U+00BA º （意大利文、葡萄牙文、西班牙文）阳性序数\n      U+00BB » 指向右的双箭头\n      U+00BC ¼ 四分之一\n      U+00BD ½ 二分之一\n      U+00BE ¾ 四分之三\n      U+00BF ¿ 倒转的问号\n      U+00C1 Á 在拉丁字母 A 上加锐音符\n      U+00C2 Â 在拉丁字母 A 上加抑扬符“^”\n      U+00C3 Ã 在拉丁字母 A 上加“~”\n      U+00C4 Ä 在拉丁字母 A 上加分音符“..”\n      U+00C5 Å 在拉丁字母 A 上加角度符“°”\n      U+00C6 Æ 拉丁字母 A、E 的混合\n      U+00C7 Ç 在拉丁字母 C 下加软音符\n      U+00C8 È 在拉丁字母 E 上加重音符\n      U+00C9 É 在拉丁字母 E 上加锐音符\n      U+00CA Ê 在拉丁字母 E 上加抑扬符\n      U+00CB Ë 在拉丁字母 E 上加分音符\n      U+00CC Ì 在拉丁字母 I 上加重音符\n      U+00CD Í 在拉丁字母 I 上加锐音符\n      U+00CE Î 在拉丁字母 I 上加抑扬符\n      U+00CF Ï 在拉丁字母 I 上加分音符\n      U+00D0 Ð 古拉丁字母，现只有法罗文和冰岛文和越南语使用\n      U+00D1 Ñ 在拉丁字母 N 上加波浪纹“~”\n      U+00D2 Ò 在拉丁字母 O 上加重音符\n      U+00D3 Ó 在拉丁字母 O 上加锐音符\n      U+00D4 Ô 在拉丁字母 O 上加抑扬符\n      U+00D5 Õ 在拉丁字母 O 上加波浪纹“~”\n      U+00D6 Ö 在拉丁字母 O 上加分音符\n      U+00D7 × 乘号，亦可拖按“Alt”键，同时按“41425”五键\n      U+00D8 Ø 在拉丁字母 O 由右上至左下加对角斜线“/”\n      U+00D9 Ù 在拉丁字母 U 上加重音符\n      U+00DA Ú 在拉丁字母 U 上加锐音符\n      U+00DB Û 在拉丁字母 U 上加抑扬符\n      U+00DC Ü 在拉丁字母 U 上加分音符\n      U+00DD Ý 在拉丁字母 Y 上加锐音符\n      U+00DE Þ 古拉丁字母，现已被“Th”取替\n      U+00DF ß 德文字母\n      U+00E0 à 在拉丁字母 a 上加重音符\n      U+00E1 á 在拉丁字母 a 上加锐音符\n      U+00E2 â 在拉丁字母 a 上加抑扬符\n      U+00E3 ã 在拉丁字母 a 上加波浪纹“~”\n      U+00E4 ä 在拉丁字母 a 上加分音符\n      U+00E5 å 在拉丁字母 a 上加角度符“°”\n      U+00E6 æ 拉丁字母 a、e 的混合\n      U+00E7 ç 在拉丁字母 c 下加软音符\n      U+00E8 è 在拉丁字母 e 上加锐音符\n      U+00E9 é 在拉丁字母 e 上加重音符\n      U+00EA ê 在拉丁字母 e 上加抑扬符\n      U+00EB ë 在拉丁字母 e 上加分音符\n      U+00EC ì 在拉丁字母 i 上加重音符\n      U+00ED í 在拉丁字母 i 上加锐音符\n      U+00EE î 在拉丁字母 i 上加抑扬符\n      U+00EF ï 在拉丁字母 i 上加分音符\n      U+00F0 ð 古拉丁字母\n      U+00F1 ñ 在拉丁字母 n 上加波浪纹“~”\n      U+00F2 ò 在拉丁字母 o 上加重音符\n      U+00F3 ó 在拉丁字母 o 上加锐音符\n      U+00F4 ô 在拉丁字母 o 上加抑扬符\n      U+00F5 õ 在拉丁字母 o 上加波浪纹“~”\n      U+00F6 ö 在拉丁字母 o 上加分音符\n      U+00F7 ÷ 除号，亦可拖按“Alt”键，同时按“41426”五键\n      U+00F8 ø 在拉丁字母 o 由右上至左下加对角斜线“/”\n      U+00F9 ù 在拉丁字母 u 上加重音符\n      U+00FA ú 在拉丁字母 u 上加锐音符\n      U+00FB ? 在拉丁字母 u 上加抑扬符\n      U+00FC ü 在拉丁字母 u 上加分音符\n      U+00FD ý 在拉丁字母 y 上加锐音符\n      U+00FE þ 古拉丁字母，现已被“th”取替\n      U+00FF ü 在拉丁字母 u 上加分音符\n      拉丁字母（扩展 A）\n      代码 显示 描述\n      U+0100 Ā 在拉丁字母 A 上加长音符\n      U+0101 ā 在拉丁字母 a 上加长音符\n      U+0102 Ă 在拉丁字母 A 上加短音符\n      U+0103 ă 在拉丁字母 a 上加短音符\n      U+0104 Ą 在拉丁字母 A 上加反尾形符\n      U+0105 ą 在拉丁字母 a 上加反尾形符\n      拉丁字母（扩展 C）\n      代码 显示 描述\n      U+2C60 Ⱡ 在拉丁字母“L”中间加两条横线“=”\n      U+2C61 ⱡ 在拉丁字母“l”（L 的小写）中间加两条横线“=”\n      U+2C62 Ɫ 在拉丁字母“L”（大写）中间加一条波浪线“~”\n      U+2C63 Ᵽ 在拉丁字母“P”中间加一条横线“-”\n      U+2C64 Ɽ 在拉丁字母“R”下加一条尾巴\n      U+2C65 ⱥ 在拉丁字母“a”上加一条对角斜线“/”\n      U+2C66 ⱦ 在拉丁字母“t”上加一条对角斜线“/”\n      U+2C67 Ⱨ 在拉丁字母“H”下加一条尾巴\n      U+2C68 ⱨ 在拉丁字母“h”下加一条尾巴\n      U+2C69 Ⱪ 在拉丁字母“K”下加一条尾巴\n      U+2C6A ⱪ 在拉丁字母“k”下加一条尾巴\n      U+2C6B Ⱬ 在拉丁字母“Z”下加一条尾巴\n      U+2C6C ⱬ 在拉丁字母“z”下加一条尾巴\n      U+2C74 ⱴ 在拉丁字母“v”的起笔加一个弯勾\n      U+2C75 Ⱶ 拉丁字母“H”的左半部\n      U+2C76 ⱶ 拉丁字母“h”的左半部\n      U+2C77 ⱷ 希腊字母“φ”的上半部\n      */\n      if (/.*[\\u00A1-\\u0105]+.*$/.test(str)) {\n        return true;\n      }\n      if (/.*[\\u2C60-\\u2C77]+.*$/.test(str)) {\n        return true;\n      }\n\n\n      return false;\n    }\n  },\n  //用户第一次打开网页时，自动判断当前用户所在国家使用的是哪种语言，来自动进行切换为用户所在国家的语种。\n  //如果使用后，第二次在用，那就优先以用户所选择的为主\n  executeByLocalLanguage: function () {\n    translate.request.post(translate.request.api.host + translate.request.api.ip + '?v=' + translate.version, {}, function (data) {\n      //console.log(data); \n      if (data.result == 0) {\n        console.log('==== ERROR 获取当前用户所在区域异常 ====');\n        console.log(data.info);\n        console.log('==== ERROR END ====');\n      } else {\n        translate.setUseVersion2();\n        translate.storage.set('to', data.language);\t//设置目标翻译语言\n        translate.to = data.language; //设置目标语言\n        translate.selectLanguageTag\n        translate.execute(); //执行翻译\n      }\n    });\n  },\n\n  util: {\n    /* 生成一个随机UUID，复制于 https://gitee.com/mail_osc/kefu.js */\n    uuid: function () {\n      var d = new Date().getTime();\n      if (window.performance && typeof window.performance.now === \"function\") {\n        d += performance.now(); //use high-precision timer if available\n      }\n      var uuid = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n      });\n      return uuid;\n    },\n\n    //判断字符串中是否存在tag标签。 true存在\n    findTag: function (str) {\n      var reg = /<[^>]+>/g;\n      return reg.test(str);\n    },\n    //传入一个数组，从数组中找出现频率最多的一个返回。 如果多个频率出现的次数一样，那会返回多个\n    arrayFindMaxNumber: function (arr) {\n\n      // 储存每个元素出现的次数\n      var numbers = {}\n\n      // 储存出现最多次的元素\n      var maxStr = []\n\n      // 储存最多出现的元素次数\n      var maxNum = 0\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (!numbers[arr[i]]) {\n          numbers[arr[i]] = 1\n        } else {\n          numbers[arr[i]]++\n        }\n\n        if (numbers[arr[i]] > maxNum) {\n          maxNum = numbers[arr[i]]\n        }\n      }\n\n      for (var item in numbers) {\n        if (numbers[item] === maxNum) {\n          maxStr.push(item)\n        }\n      }\n\n      return maxStr;\n    },\n    //对字符串进行hash化，目的取唯一值进行标识\n    hash: function (str) {\n      if (str == null || typeof (str) == 'undefined') {\n        return str;\n      }\n      var hash = 0, i, chr;\n      if (str.length === 0) {\n        return hash;\n      }\n\n      for (i = 0; i < str.length; i++) {\n        chr = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + chr;\n        hash |= 0; // Convert to 32bit integer\n      }\n      return hash + '';\n    },\n    //去除一些指定字符，如换行符。 如果传入的是null，则返回空字符串\n    charReplace: function (str) {\n\n      if (str == null) {\n        return '';\n      }\n      str = str.trim();\n      str = str.replace(/\\t|\\n|\\v|\\r|\\f/g, '');\t//去除换行符等\n      //str = str.replace(/&/g, \"%26\"); //因为在提交时已经进行了url编码了\n      return str;\n    },\n    //RegExp相关\n    regExp: {\n      // new RegExp(pattern, resultText); 中的 pattern 字符串的预处理\n      pattern: function (str) {\n        //str = str.replace(/'/g,'\\\\\\'');\n        str = str.replace(/\\\"/g, '\\\\\\\"');\n        //str = str.replace(/./g,'\\\\\\.');\n        str = str.replace(/\\?/g, '\\\\\\?');\n        str = str.replace(/\\$/g, '\\\\\\$');\n        return str;\n      },\n      // new RegExp(pattern, resultText); 中的 resultText 字符串的预处理\n      resultText: function (str) {\n        //str = str.replace(/&quot;/g,\"\\\"\");\n        //str = str.replace(/'/g,\"\\\\\\'\");\n        //str = str.replace(/\"/g,\"\\\\\\\"\");\n        return str;\n      }\n    },\n    //获取URL的GET参数。若没有，返回\"\"\n    getUrlParam: function (name) {\n      var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\");\n      var r = window.location.search.substr(1).match(reg);\n      if (r != null) return unescape(r[2]); return \"\";\n    },\n    /**\n     * 同步加载JS，加载过程中会阻塞，加载完毕后继续执行后面的。\n     * url: 要加载的js的url\n     */\n    synchronizesLoadJs: function (url) {\n      var xmlHttp = null;\n      if (window.ActiveXObject) {//IE  \n        try {\n          //IE6以及以后版本中可以使用  \n          xmlHttp = new ActiveXObject(\"Msxml2.XMLHTTP\");\n        } catch (e) {\n          //IE5.5以及以后版本可以使用  \n          xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n      } else if (window.XMLHttpRequest) {\n        //Firefox，Opera 8.0+，Safari，Chrome  \n        xmlHttp = new XMLHttpRequest();\n      }\n      //采用同步加载  \n      xmlHttp.open(\"GET\", url, false);\n      //发送同步请求，如果浏览器为Chrome或Opera，必须发布后才能运行，不然会报错  \n      xmlHttp.send(null);\n      //4代表数据发送完毕  \n      if (xmlHttp.readyState == 4) {\n        //0为访问的本地，200到300代表访问服务器成功，304代表没做修改访问的是缓存  \n        if ((xmlHttp.status >= 200 && xmlHttp.status < 300) || xmlHttp.status == 0 || xmlHttp.status == 304) {\n          var myBody = document.getElementsByTagName(\"HTML\")[0];\n          var myScript = document.createElement(\"script\");\n          myScript.language = \"javascript\";\n          myScript.type = \"text/javascript\";\n          try {\n            //IE8以及以下不支持这种方式，需要通过text属性来设置  \n            myScript.appendChild(document.createTextNode(xmlHttp.responseText));\n          } catch (ex) {\n            myScript.text = xmlHttp.responseText;\n          }\n          myBody.appendChild(myScript);\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    },\n    //加载 msg.js\n    loadMsgJs: function () {\n      if (typeof (msg) != 'undefined') {\n        return;\n      }\n      translate.util.synchronizesLoadJs('http://res.zvo.cn/msg/msg.js');\n    },\n    /*\n      对一个对象，按照对象的key的长度进行排序，越长越在前面\n    */\n    objSort: function (obj) {\n      // 获取对象数组的所有 key，并转换为普通数组\n      var keys = Array.from(Object.keys(obj));\n\n      // 对 key 数组进行排序\n      keys.sort(function (a, b) {\n        return b.length - a.length;\n      });\n\n      // 定义一个新的对象数组，用来存储排序后的结果\n      var sortedObj = new Array();\n\n      // 遍历排序后的 key 数组，将对应的值复制到新的对象数组中，并删除原来的对象数组中的键值对\n      for (var key of keys) {\n        sortedObj[key] = obj[key];\n      }\n      return sortedObj;\n    }\n  },\n  //request请求来源于 https://github.com/xnx3/request\n  request: {\n    //相关API接口方面\n    api: {\n      /**\n       * 翻译接口请求的域名主机 host\n       * 格式注意前面要带上协议如 https:// 域名后要加 /\n       */\n      host: 'https://api.translate.zvo.cn/',\n      language: 'language.json', //获取支持的语种列表接口\n      translate: 'translate.json', //翻译接口\n      ip: 'ip.json' //根据用户当前ip获取其所在地的语种\n    },\n    /**\n     * post请求\n     * @param url 请求的接口URL，传入如 http://www.xxx.com/a.php\n     * @param data 请求的参数数据，传入如 {\"goodsid\":\"1\", \"author\":\"管雷鸣\"}\n     * @param func 请求完成的回调，传入如 function(data){ console.log(data); }\n     */\n    post: function (url, data, func) {\n      var headers = {\n        'content-type': 'application/x-www-form-urlencoded',\n      };\n      this.send(url, data, func, 'post', true, headers, null);\n    },\n    /**\n     * 发送请求\n     * url 请求的url\n     * data 请求的数据，如 {\"author\":\"管雷鸣\",'site':'www.guanleiming.com'} \n     * func 请求完成的回调，传入如 function(data){}\n     * method 请求方式，可传入 post、get\n     * isAsynchronize 是否是异步请求， 传入 true 是异步请求，传入false 是同步请求\n     * headers 设置请求的header，传入如 {'content-type':'application/x-www-form-urlencoded'};\n     * abnormalFunc 响应异常所执行的方法，响应码不是200就会执行这个方法 ,传入如 function(xhr){}\n     */\n    send: function (url, data, func, method, isAsynchronize, headers, abnormalFunc) {\n      //post提交的参数\n      var params = '';\n      if (data != null) {\n        for (var index in data) {\n          if (params.length > 0) {\n            params = params + '&';\n          }\n          params = params + index + '=' + data[index];\n        }\n      }\n\n      var xhr = null;\n      try {\n        xhr = new XMLHttpRequest();\n      } catch (e) {\n        xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n      //2.调用open方法（true----异步）\n      xhr.open(method, url, isAsynchronize);\n      //设置headers\n      if (headers != null) {\n        for (var index in headers) {\n          xhr.setRequestHeader(index, headers[index]);\n        }\n      }\n      xhr.send(params);\n      //4.请求状态改变事件\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          if (xhr.status == 200) {\n            //请求正常，响应码 200\n            var json = null;\n            try {\n              json = JSON.parse(xhr.responseText);\n            } catch (e) {\n              console.log(e);\n            }\n            if (json == null) {\n              func(xhr.responseText);\n            } else {\n              func(json);\n            }\n          } else {\n            if (abnormalFunc != null) {\n              abnormalFunc(xhr);\n            }\n          }\n        }\n      }\n    }\n  },\n  //存储，本地缓存\n  storage: {\n    set: function (key, value) {\n      localStorage.setItem(key, value);\n    },\n    get: function (key) {\n      return localStorage.getItem(key);\n    }\n  },\n  //针对图片进行相关的语种图片替换\n  images: {\n    /* 要替换的图片队列，数组形态，其中某个数组的：\n      key：\"/uploads/allimg/160721/2-160H11URA25-lp.jpg\"; //旧图片，也就是原网站本身的图片。也可以绝对路径，会自动匹配 img src 的值，匹配时会进行完全匹配\n      value：\"https://xxx.com/abc_{language}.jpg\" //新图片，要被替换为的新图片。新图片路径需要为绝对路径，能直接访问到的。其中 {language} 会自动替换为当前要显示的语种。比如你要将你中文网站翻译为繁体中文，那这里会自动替换为：https://xxx.com/abc_chinese_traditional.jpg  有关{language}的取值，可查阅 http://api.translate.zvo.cn/doc/language.json.html 其中的语言标识id便是\n    */\n    queues: [],\n\n    /*\n      向图片替换队列中追加要替换的图片\n      传入格式如：\n    \t\n      translate.images.add({\n        \"/uploads/a.jpg\":\"https://www.zvo.cn/a_{language}.jpg\",\n        \"/uploads/b.jpg\":\"https://www.zvo.cn/b_{language}.jpg\",\n      });\n    \t\n      参数说明：\n      key  //旧图片，也就是原网站本身的图片。也可以绝对路径，会自动匹配 img src 的值，匹配时会进行完全匹配\n      value //新图片，要被替换为的新图片。新图片路径需要为绝对路径，能直接访问到的。其中 {language} 会自动替换为当前要显示的语种。比如你要将你中文网站翻译为繁体中文，那这里会自动替换为：https://xxx.com/abc_chinese_traditional.jpg  有关{language}的取值，可查阅 http://api.translate.zvo.cn/doc/language.json.html 其中的语言标识id便是\n    */\n    add: function (queueArray) {\n      /*\n      translate.images.queues[translate.images.queues.length] = {\n        old:oldImage,\n        new:newImage\n      }\n      */\n      for (var key in queueArray) {\n        translate.images.queues[key] = queueArray[key];\n      }\n    },\n    //执行图片替换操作，将原本的图片替换为跟翻译语种一样的图片\n    execute: function () {\n      if (Object.keys(translate.images.queues).length < 1) {\n        //如果没有，那么直接取消图片的替换扫描\n        return;\n      }\n\n      var imgs = document.getElementsByTagName('img');\n      for (var i = 0; i < imgs.length; i++) {\n        var img = imgs[i];\n        if (typeof (img.src) == 'undefined' || img.src == null || img.src.length == 0) {\n          continue;\n        }\n\n        for (var key in translate.images.queues) {\n          var oldImage = key; //原本的图片src\n          var newImage = translate.images.queues[key]; //新的图片src，要替换为的\n          //console.log('queue+'+oldImage);\n          if (oldImage == img.src) {\n            //console.log('发现匹配图片:'+img.src);\n            /*\n            //判断当前元素是否在ignore忽略的tag、id、class name中\n            if(translate.ignore.isIgnore(node)){\n              console.log('node包含在要忽略的元素中：');\n              console.log(node);\n              continue;\n            }\n            */\n\n            //没在忽略元素里，可以替换\n            img.src = newImage.replace(new RegExp('{language}', 'g'), translate.to);\n          }\n        }\n\n      }\n\n\n      /********** 还要替换style中的背景图 */\n      /*\n    \t\n        var elements = document.querySelectorAll('[style*=\"background-image\"], [style*=\"background\"]');\n        for (var i = 0; i < elements.length; i++) {\n            var style = window.getComputedStyle(elements[i]);\n            var backgroundImage = style.getPropertyValue('background-image');\n            if (backgroundImage !== 'none') {\n                console.log(backgroundImage);\n            }\n        }\n\n      */\n\n    }\n  },\n\n  /*\n    划词翻译，鼠标在网页中选中一段文字，会自动出现对应翻译后的文本\n    有网友 https://gitee.com/huangguishen 提供。\n    详细使用说明参见：http://translate.zvo.cn/41557.html\n  */\n  selectionTranslate: {\n    selectionX: 0,\n    selectionY: 0,\n    callTranslate: function (event) {\n      let curSelection = window.getSelection();\n      //相等认为没有划词\n      if (curSelection.anchorOffset == curSelection.focusOffset) return;\n      let translateText = window.getSelection().toString();\n\n      //简单Copy原有代码了\n      var url = translate.request.api.host + translate.request.api.translate + '?v=' + translate.version;\n      var data = {\n        from: translate.language.getLocal(),\n        to: translate.to,\n        text: encodeURIComponent(JSON.stringify([translateText]))\n      };\n      translate.request.post(url, data, function (data) {\n        if (data.result == 0) return;\n        let curTooltipEle = document.querySelector('#translateTooltip')\n        curTooltipEle.innerText = data.text[0];\n        curTooltipEle.style.top = selectionY + 20 + \"px\";\n        curTooltipEle.style.left = selectionX + 50 + \"px\";\n        curTooltipEle.style.display = \"\";\n      });\n    },\n    start: function () {\n      //新建一个tooltip元素节点用于显示翻译\n      let tooltipEle = document.createElement('span');\n      tooltipEle.innerText = '';\n      tooltipEle.setAttribute('id', 'translateTooltip');\n      tooltipEle.setAttribute('style', 'background-color:black;color:#fff;text-align:center;border-radius:6px;padding:5px;position:absolute;z-index:999;top:150%;left:50%; ');\n      //把元素节点添加到body元素节点中成为其子节点，放在body的现有子节点的最后\n      document.body.appendChild(tooltipEle);\n      //监听鼠标按下事件，点击起始点位置作为显示翻译的位置点\n      document.addEventListener('mousedown', (event) => { selectionX = event.pageX; selectionY = event.pageY; }, false);\n      //监听鼠标弹起事件，便于判断是否处于划词\n      document.addEventListener('mouseup', translate.selectionTranslate.callTranslate, false);\n      //监听鼠标点击事件，隐藏tooltip，此处可优化\n      document.addEventListener('click', (event) => { document.querySelector('#translateTooltip').style.display = \"none\" }, false);\n    }\n  }\n\n\n\n  /**************************** v2.0 end */\n\n}\nconsole.log('Two lines of js html automatic translation, page without change, no language configuration file, no API Key, SEO friendly! Open warehouse : https://github.com/xnx3/translate');\n\n//这个只是v1使用到\ntry {\n  translate.init();\n  //translate.execute();\n} catch (e) { console.log(e); }\n\nexport default translate"],"mappings":"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C,EAAE;QACrC,OAAO,IAAI;MACb,CAAC,MAAM;QACL,OAAO,KAAK;MACd;IACF,CAAC;IACD;IACA4I,MAAM,EAAE,SAAAA,CAAU5I,GAAG,EAAE;MACrB,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;IACD;IACA2I,gBAAgB,EAAE,SAAAA,CAAU3I,GAAG,EAAE;MAC/B;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;AACN;AACA;AACA;AACA;AACA;;MAEM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;MACA,IAAI,sEAAsE,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACpF,OAAO,IAAI;MACb;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;;MAEA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACM,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;MACA,IAAI,uBAAuB,CAACoJ,IAAI,CAACpJ,GAAG,CAAC,EAAE;QACrC,OAAO,IAAI;MACb;MAGA,OAAO,KAAK;IACd;EACF,CAAC;EACD;EACA;EACAiF,sBAAsB,EAAE,SAAAA,CAAA,EAAY;IAClC7M,SAAS,CAACyB,OAAO,CAACC,IAAI,CAAC1B,SAAS,CAACyB,OAAO,CA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}